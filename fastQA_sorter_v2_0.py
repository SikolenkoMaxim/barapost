#!/usr/bin/env python3

# Version 2.0
# 30.08.2019 edition

# |===== Check python interpreter version =====|

from sys import version_info as verinf

if verinf.major < 3:#{
    print( "\nYour python interpreter version is " + "%d.%d" % (verinf.major, verinf.minor) )
    print("\tPlease, use Python 3!\a")
    # In python 2 'raw_input' does the same thing as 'input' in python 3.
    # Neither does 'input' in python2.
    raw_input("Press ENTER to exit:")
    exit(1)
#}

# |===== Stuff for dealing with time =====|

from time import time, strftime, localtime, sleep
start_time = time()


def get_work_time():#{
    return strftime("%H:%M:%S", localtime( time() ))
#}

# Get start time
from datetime import datetime
now = datetime.now().strftime("%Y-%m-%d %H.%M.%S")
# -------------------

print("\n |=== fastQA_sorter.py (version 2.0) ===|\n\n")
# -------------------

from sys import platform

def platf_depend_exit(exit_code):#{
    """
    A function that asks to press ENTER on Windows
        and exits.

    :type exit_code: int;
    """
    if platform.startswith("win"):
        input("Press ENTER to exit:")
    exit(exit_code)
#}
# -------------------


from gzip import open as open_as_gzip
from re import search as re_search
import os
import getopt
from sys import argv
from sys import intern
# -------------------


help_msg = """
DESCRIPTION:\n
 fastQA_forter.py -- script designed for sorting FASTQ and FASTAfiles processed by barapost.py.\n
 'fastQA_forter.py' is meant to be used just after 'barapost.py'.\n
 - Separate FASTQ or FASTA files should be specified with -f(--infile) option (see EXAMPLES below).
 - If -d (--indir) option is specified, all FASTQ and FASTA files in directory specified by this option will be sorted.
 - If no separate FASTQ or FASTA files and not input directory is specified,
       fastQA_sorter will process all FASTQ and FASTA files in current directory.
--------------------------------

Default parameters:\n
- all FASTQ and FASTA files in current directory will be processed;
- sorting sensitivity (see '-s' option): 'species';
- output directory ('-o' option): directory named '"fastQA_sorter_result_<date_and_time_of_run>"''
  nested in current directory;
--------------------------------

OPTIONS (* means mandatory option):\n
    -h (--help) --- show help message;\n
  * -r (--prober-result-dir) --- result directory genearted by script 'prober.py'
        This is directory specified to 'prober.py' by '-o' option.
        Or named 'prober_result' if you've ran 'prober.py' with default options.
    -f (--infile) --- input FASTQ of FASTA file (can be gzipped);\n
    -d (--indir) --- directory which contains FASTQ and/or FASTA files (files can be gzipped) meant to be sorted;\n
    -o (--outdir) --- output directory;\n
    -s (--sorting-sensitivity) --- sorting sensitivity,
        e.i. the lowest taxonomy rank that will be used in names of resut files;
        Available values: 'genus', 'species', 'strain'; Default is 'species'.
--------------------------------

EXAMPLES:\n
  1) Process one FASTQ file with default settings.
     File 'reads.fastq' has been already processed by 'barapost.py'.
     Results of 'barapost.py' work are in directory 'prober_outdir':\n
        ./fastq_sorter.py -f reads.fastq.gz -r prober_outdir/\n
  2) Process a FASTQ file and a FASTA file, place results in "outdir" directory.
     Files 'reads.fastq.gz' and 'another_sequences.fasta' have been already processed by 'barapost.py'.
     Results of 'barapost.py' work are in directory 'prober_outdir':\n
        ./fastq_sorter.py -f reads_1.fastq.gz -f some_sequences_2.fasta -o outdir -r prober_outdir/\n
  3) Process all FASTQ and FASTA files in directory named "dir_with_seqs". Sort by genus.
     All these files have been already processed by 'barapost.py'.
     Results of 'barapost.py' work are in directory 'prober_outdir':\n
        ./fastq_sorter.py -d dir_with_seqs -o outdir -r prober_outdir/ -s genus
"""
# -------------------


try:#{
    opts, args = getopt.getopt(argv[1:], "hr:f:d:o:s:", ["help", "prober-result-dir=", "indir=", "outdir=",
        "sorting-sensitivity="])
#}
except getopt.GetoptError as gerr:#{
    print( str(gerr) )
    platf_depend_exit(2)
#}
# -------------------


is_fq_or_fa = lambda f: True if not re_search(r".*\.f(ast)?(a|q)(\.gz)?$", f) is None else False
fq_fa_paths = list() # input FASTQ files paths
prober_res_dir = None # path to result TSV file generated by barapost.py
indir_path = None # path to input directory
outdir_path = "fastQA_sorter_result_{}".format(now) # defalut value
sens = "species"

for opt, arg in opts:#{

    if opt in ("-h", "--help"):#{
        print(help_msg)
        platf_depend_exit(0)
    #}

    if opt in ("-f", "--infile"):#{
        if not os.path.exists(arg):#{
            print("\n\t\a!! - ERROR: file '{}' does not exist!".format(arg))
            platf_depend_exit(1)
        if not is_fq_or_fa(arg):#{
            print(" !! - Warning: file '{}' is not '.fastq' and not '.fasta'!".format(arg))
            platf_depend_exit(1)
        #}
        fq_fa_paths.append(os.path.abspath(arg))
    #}

    if opt in ("-d", "--indir"):#{
        if not os.path.exists(arg):#{
            print("\n\t\a!! - ERROR: directory '{}' does not exist!".format(arg))
            platf_depend_exit(1)
        #}
        if not os.path.isdir(arg):#{
            print("\n\t\a!! - ERROR: '{}' is not a directory!".format(arg))
            platf_depend_exit(1)
        #}
        indir_path = os.path.abspath(arg)
    #}

    if opt in ("-o", "--outdir"):#{
        outdir_path = os.path.abspath(arg)
    #}

    if opt in ("-r", "--prober-result-dir"):#{
        if not os.path.exists(arg):#{
            print_error("directory '{}' does not exist!".format(arg))
            platf_depend_exit(1)
        #}
        if not os.path.isdir(arg):#{
            print_error("'{}' is not a directory!".format(arg))
            platf_depend_exit(1)
        #}
        prober_res_dir = arg
    #}

    if opt in ("-s", "--sorting-sensitivity"):#{
        if arg not in ("genus", "species", "strain"):#{
            print("\n\t\a!!- ERROR: invalid value specified by '-s' option!\n")
            print("Available values: 'genus', 'species', 'strain'")
            print("\nType for help:\n    ./fastQA_forter.py -h")
            platf_depend_exit(1)
        #}
        sens = arg
    #}
#}

# Check if prober.py result directory is specified
if prober_res_dir is None:#{
    print("\n\t\a!! - ERROR: '-r' option is mandatory!\n")
    platf_depend_exit(1)
#}

# Collect FASTQ and FASTA files from input directory
if indir_path is not None:#{
    indir_fastqs = list( filter(is_fq_or_fa, os.listdir(indir_path)) )
    fq_fa_paths.extend(indir_fastqs)
#}

# If no FASTQ or FASTA file have been found
if len(fq_fa_paths) == 0:#{
    # If input directory was specified -- exit
    if not indir_path is None:#{
        print("\n\t\a !! - ERROR: no input FASTQ or FASTA files specified or there is no FASTQ or FASTA files in the input directory.\n")
        platf_depend_exit(1)
    #}
    # If input directory was not specified -- look for FASTQ and FASTA files in current directory
    else:#{
        currdir_fastqs = list( filter(is_fq_or_fa, os.listdir('.')) )
        fq_fa_paths.extend(currdir_fastqs)
    #}
#}

del help_msg # we do not need this large string any more

print("\n Following files will be processed:")
for i, path in enumerate(fq_fa_paths):#{
    print("  {}. {}".format(i+1, path))
#}
print('-'*20 + '\n')


#                      Genus    species                   strain name and anything after it
hit_name_pattern = r"^[A-Z][a-z]+_[a-z]*(sp\.)?(phage)?_(strain_)?.+$"


def format_taxonomy_name(hit_name, sens):#{
    """
    Function formats taxonomy name according to chosen sensibiliry of sorting.
    :param hit_name: full_fit_name_of_the_subject_sequence;
    :type hit_name: str;
    :param sens: sensibility returned by 'get_classif_sensibility()' function.
        It's value can be one of the following strings: "genus", "sprcies", "strain";
    :type sens: str;
    Returns formatted hit name of 'str' type;
    """

    if hit_name == "No significant similarity found":#{
        return "unknown"
    #}

    # If structure of hit name is strange
    if re_search(hit_name_pattern, hit_name.strip()) is None:#{
        print("\n\tAttention!")
        print("Hit name '{}' has structure that hasn't been anticipated by the developer.".format(hit_name))
        print("This name migth be formatted incorrectly.")
        print("Therefore, full name ({}) will be used.".format(hit_name.strip()))
        print("Contact the developer -- send this name to him.")

        return hit_name.strip().replace(' ', '_')   # return full name
    #}

    taxa_name = hit_name.partition(',')[0]
    taxa_splitnames = taxa_name.strip().split('_')

    # If hit is a phage sequence
    if taxa_splitnames[1] == "phage":#{
        # Assumming that the man who sortes by genus or species isn't interested in phage strain name
        if sens == "genus" or sens == "species":
            return '_'.join( [taxa_splitnames[0], taxa_splitnames[1]] ) # return "<Host_name> phage"
        else:
            return taxa_name.replace(' ', '_')   # return full name if we sort by strain
    #}

    if sens == "genus":#{
        return taxa_splitnames[0] # return genus
    #}
    elif sens == "species":#{
        if taxa_splitnames[1] == "sp.":#{ if species is not specified
            return taxa_name.replace(' ', '_')   # return full name
        #}
        else:#{
            return '_'.join( [taxa_splitnames[0], taxa_splitnames[1]] ) # return genus and species
        #}
    #}
    elif sens == "strain":#{
        return taxa_name.replace(' ', '_')   # return full name
    #}

    # Execution should not reach here
    raise Exception("Taxonomy name formatting error!")
#}


# Data from plain text and gzipped should be parsed in different way,
#   because data from .gz is read as 'bytes', not 'str'.
FORMATTING_FUNCS = (
    lambda line: line,   # format text line
    lambda line: line.decode("utf-8")  # format gzipped line
)


def read_fastq_record(read_file, fmt_func):#{
    """
    :param read_file: file instance of FASTQ file to retrieve sequences from;
    :type fasta_file: _io.TextIOWrapper or gzip.GzipFile;

    Returns dictionary of the following structure:
    {
        "seq_id": ID_of_sequence,
        "seq": sequence_itself,
        "opt_id": the_third_line,
        "qual_line": quality_line
    }
    """

    fastq_rec = dict()

    try:#{
        fastq_rec = {                    #read all 4 lines of fastq-record
            "seq_id": fmt_func(read_file.readline()),
            "seq": fmt_func(read_file.readline()),
            "opt_id": fmt_func(read_file.readline()),
            "qual_line": fmt_func(read_file.readline())
        }
    #}
    except Exception as err:#{
        print_red("\nAn error occured while reading from infile")
        print( str(err) )
        platf_depend_exit(1)
    #}

    return fastq_rec
#}


def read_fasta_record(read_file, fmt_func):#{
    """
    :param read_file: file instance of FASTA file to retrieve sequences from;
    :type fasta_file: _io.TextIOWrapper or gzip.GzipFile;

    Returns dictionary of the following structure:
    {
        "seq_id": ID_of_sequence,
        "seq": sequence_itself
    }
    """

    fasta_rec = dict()

    try:#{
        fasta_rec = {                    #read all 2 lines of FASTA-record
            "seq_id": fmt_func(read_file.readline()),
            "seq": fmt_func(read_file.readline())
        }
    #}
    except Exception as err:#{
        print_red("\nAn error occured while reading from infile")
        print( str(err) )
        platf_depend_exit(1)
    #}

    return fasta_rec
#}


def write_fastq_record(outfile_path, fastq_record):#{
    """
    :param outfile: file, which data from fastq_record is written in
    :type outfile: _io.TextIOWrapper
    :param fastq_record: dict of 4 elements. Elements are four corresponding lines of FASTQ
    :type fastq_record: dict<str: str>

    Returns None
    """
    try:#{
        with open_as_gzip(outfile_path, 'ab') as sorted_file:
            sorted_file.write(bytes(fastq_record["seq_id"], "utf-8"))
            sorted_file.write(bytes(fastq_record["seq"], "utf-8"))
            sorted_file.write(bytes(fastq_record["opt_id"], "utf-8"))
            sorted_file.write(bytes(fastq_record["qual_line"], "utf-8"))
    #}
    except Exception as exc:#{
        print_red("\nAn error occured while writing to outfile")
        print( str(exc) )
        platf_depend_exit(1)
    #}
#}


def write_fasta_record(outfile_path, fasta_record):#{
    """
    :param outfile: file, which data from fasta_record is written in
    :type outfile: _io.TextIOWrapper
    :param fasta_record: dict of 2 elements. Elements are four corresponding lines of FASTA
    :type fasta_record: dict<str: str>

    Returns None
    """
    try:#{
        with open_as_gzip(outfile_path, 'ab') as sorted_file:
            sorted_file.write(bytes(fasta_record["seq_id"], "utf-8"))
            sorted_file.write(bytes(fasta_record["seq"], "utf-8"))
    #}
    except Exception as exc:#{
        print_red("\nAn error occured while writing to outfile")
        print( str(exc) )
        platf_depend_exit(1)
    #}
#}


is_gzipped = lambda f: True if f.endswith(".gz") else False
OPEN_FUNCS = (open, open_as_gzip)


# |===== Create output directory =====|
if not os.path.exists(outdir_path):#{
    try:#{
        os.makedirs(outdir_path)
    #}
    except Exception as err:#{
        print("\n\a\t!! - ERROR: unable to create output directory!")
        print( str(err) )
        platf_depend_exit(1)
    #}
#}


def get_curr_res_dir(fq_fa_path, prober_res_dir):#{
    
    # dpath means "directory path"
    new_dpath = os.path.join(prober_res_dir, os.path.basename(fq_fa_path)) # get rid of absolute path
    new_dpath = new_dpath[: new_dpath.rfind(".fast")] # get rid of extention

    return new_dpath
#}


# |=== Function for configuring dictionary containing information generated by barapost.py ===|

def get_res_tsv_fpath(new_dpath):#{

    brpst_resfile_patt = r".+_result\.tsv$"

    is_similar_to_tsv_res = lambda f: True if not re_search(brpst_resfile_patt, f) is None else False

    # Recent file will be the first in sorted list
    tsv_res_fpath = list( filter(is_similar_to_tsv_res, sorted(os.listdir(new_dpath))) )[0]

    return os.path.join(new_dpath, tsv_res_fpath)
#}


def configure_resfile_lines(tsv_res_fpath):#{

    resfile_lines = dict()

    with open(tsv_res_fpath, 'r') as brpst_resfile:#{

        brpst_resfile.readline() # pass the head of the table
        line = brpst_resfile.readline().strip() # get the first informative line

        while line is not "":#{
            read_name = intern(line.split('\t')[0])
            hit_name = line.split('\t')[1]
            resfile_lines[read_name] = hit_name

            line = brpst_resfile.readline().strip() # get next line
        #}
    #}

    # |===== Format taxonomy names =====|
    for read_name in resfile_lines.keys():#{
        resfile_lines[read_name] = format_taxonomy_name(resfile_lines[read_name], sens)
    #}

    return resfile_lines
#}

print("{} - Start working".format(get_work_time()))

LINES_PER_READ_FASTQ = 4
LINES_PER_SEQ_FASTA = 2
is_fastq = lambda f: True if not re_search(r".*\.fastq(\.gz)?$", f) is None else False
num_files = len(fq_fa_paths)

for j, fq_fa_path in enumerate(fq_fa_paths):#{

    print("\n{} - '{}' is sorting ...".format(get_work_time(), os.path.basename(fq_fa_path)))

    new_dpath = get_curr_res_dir(fq_fa_path, prober_res_dir)
    tsv_res_fpath = get_res_tsv_fpath(new_dpath)
    resfile_lines = configure_resfile_lines(tsv_res_fpath)

    # Prune name of source FASTQ or FASTA file
    # source_path_pruned = os.path.basename(fq_fa_path) # get rid of absolute path
    # source_path_pruned = source_path_pruned.partition(".fast")[0] # get rid of extention

    how_to_open = OPEN_FUNCS[ is_gzipped(fq_fa_path) ] # get ready to open gzipped files
    lines_format = LINES_PER_READ_FASTQ if is_fastq(fq_fa_path) else LINES_PER_SEQ_FASTA
    num_reads = int (sum(1 for line in how_to_open(fq_fa_path)) / lines_format) # count number of reads in file

    # Get function that will read one record -- FASTQ of FASTA, in dependence of your file
    read_fun = read_fastq_record if is_fastq(fq_fa_path) else read_fasta_record
    # Get function that will write one record -- FASTQ of FASTA, in dependence of your file
    write_fun = write_fastq_record if is_fastq(fq_fa_path) else write_fasta_record
    
    with how_to_open(fq_fa_path) as source_fastq_file:#{

        fmt_func = FORMATTING_FUNCS[ is_gzipped(fq_fa_path) ]

        for i in range(num_reads):#{

            fastq_rec = read_fun(source_fastq_file, fmt_func) # get FASTQ or FASTA record
            read_name = intern(fastq_rec["seq_id"].partition(' ')[0][1:]) # get ID of the sequence

            try:#{
                hit_name = resfile_lines[read_name] # find hit corresponding to this sequence
            #}
            except KeyError:#{
                print("\n\t\a !! - Warning: read '{}' not found in '{}' result file".format(read_name, prober_res_dir))
                print("Make sure that this read has been already baraposted.")
                continue
            #}
            # If read is found in TSV file:
            else:#{
                # Get name of resilt FASTQ file to write this read in
                sorted_file_path = os.path.join(outdir_path, "{}.fast{}.gz".format(hit_name,
                    'q' if is_fastq(fq_fa_path) else 'a'))
                write_fun(sorted_file_path, fastq_rec) # write current read to sorted file
            #}

            print("\r{} - {}/{} reads are sorted  ".format(get_work_time(), i+1, num_reads), end="")
        #}
        print('\n' + '-'*20)
    #}
#}

print("\n{} - Sorting has been successfully completed!".format(get_work_time()))
platf_depend_exit(0)