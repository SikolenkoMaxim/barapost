#!/usr/bin/env python3
# -*- coding: utf-8 -*-

__version__ = "4.2.b"
# Year, month, day
__last_update_date__ = "2020-01-29"

# |===== Check python interpreter version =====|

import sys

if sys.version_info.major < 3:
    print( "\nYour python interpreter version is " + "%d.%d" % (sys.version_info.major, sys.version_info.minor) )
    print("   Please, use Python 3!\a")
    # In python 2 'raw_input' does the same thing as 'input' in python 3.
    # Neither does 'input' in python2.
    raw_input("Press ENTER to exit:")
    exit(1)
# end if


from src.platform import platf_depend_exit, get_logfile_path

# Firstly search for information-providing options:

if "-h" in sys.argv[1:] or "--help" in sys.argv[1:]:
    print("\n  fastQA5-sorter.py\n  Version {}; {} edition;\n".format(__version__, __last_update_date__))
    print("DESCRIPTION:\n")
    print("""fastQA5-sorter.py -- this script is designed for sorting (dividing into separate files)
    FASTQ and FASTA files processed by "barapost.py".""")

    if "--help" in sys.argv[1:]:
        print("""Moreover, it can sort FAST5 files according to taxonomical annotation of FASTQ files,
    that are result of basecalling these FAST5 files. For details, see README.md
    on github page ('FAST5 sorting' section): https://github.com/masikol/barapost\n
"fastQA5-sorter.py" is meant to be used just after "barapost.py".""")
        print("""----------------------------------------------------------\n
Default parameters:\n
- all FASTQ, FASTA and FAST5 files in current directory will be processed;
- sorting sensitivity (see '-s' option): 'genus';
- output directory ('-o' option): directory named '"sorter_result_<date_and_time_of_run>"''
  nested in current directory;
- minimum mean quality of a read to keep ('-q' option): 10;
- length filtering ('-m' option) is disabled;
- "FAST5 untwisting" is disaled by default;""")
    # end if

    print("----------------------------------------------------------\n")
    print("""Files that you want 'fastQA5-sorter.py' to process should be
    specified as positional arguments (see EXAMPLE #2 running detailed (--help) help message).
Wildcards do work: './fastQA5-sorter.py my_directory/*' will process all files in 'my_directory'.\n""")
    print("OPTIONS:\n")
    print("""-h (--help) --- show help message.
        '-h' -- brief, '--help' -- full;\n""")
    print("-v (--version) --- show version;\n")
    print("""-r (--taxannot-resdir) --- result directory genearted by script 'prober.py'
        This is directory specified to 'prober.py' by '-o' option.
        Default value is "barapost_result", since it is the default name of
        output directory generated by "prober.py".\n""")
    print("""-d (--indir) --- directory which contains FAST(Q/A/5) files
        (FASTQ and FASTA files can be gzipped) meant to be sorted;\n""")
    print("-o (--outdir) --- output directory;\n")
    print("""-s (--sorting-sensitivity) --- sorting sensitivity,
        i.e. the lowest taxonomy rank that will be used in names of resut files;
        Available values: 'genus', 'species'; Default is 'genus'.\n""")
    print("""-q (--min-ph33-qual) --- minimum mean Q quality of a read to keep;
        Reads of lower quality will be written to separate "trash" file;
        Default value: 10;\n""")
    print("""-m (--min-seq-len) --- minimum length of a sequence to keep.
        Shorter sequences will be written to separate "trash" file.
        Length filtering is disabled by default;\n""")
    print("""-u (--untwist-fast5) --- flag option. If specified, FAST5 files will be
        sorted considering that they and "corresponding" FASTQ files contain
        different reads (like after basecalling performed by Guppy).
        Disabled by default;\n""")
    print("""-z (--gzip) --- Compress output files with gzip.
        Compression affects only FASTA and FASTQ files;
        Values: 'true', 'false' (see Example #2).
        'true' by default.""")
    print("""-t (--threads) --- number of threads to launch.
        Affects only FASTA and FASTQ sorting. Sorter processes FAST5 files in 1 thread anyway.""")

    if "--help" in sys.argv[1:]:
        print("----------------------------------------------------------\n")
        print("EXAMPLES:\n")
        print("""  1. Process all FASTA and FASTQ files in working directory with default settings:\n
  ./fastQA5-sorter.py\n""")
        print("""  2. Process all files in the working directory that start with "some_my_fastq".
  Ignore reads with mean quality < 15. Do not compress output files.
  The rest of settings are default:\n
  ./fastQA5-sorter.py some_my_fastq* -q 15 -z false\n""")
        print("""  3. Process one FASTQ file with default settings.
  File 'reads.fastq' has been already processed by "barapost.py".
  Results of "barapost.py" work are in directory 'prober_outdir':\n
  ./fastQA5-sorter.py reads.fastq.gz -r prober_outdir/\n""")
        print("""  4. Process a FASTQ file and a FASTA file, place results in 'outdir' directory.
  Files 'reads.fastq.gz' and 'another_sequences.fasta' have been already processed by "barapost.py".
  Results of "barapost.py" work are in directory 'prober_outdir':\n
  ./fastQA5-sorter.py reads_1.fastq.gz some_sequences_2.fasta -o outdir -r prober_outdir/\n""")
        print("""  5. Process all FASTQ and FASTA files in directory named 'dir_with_seqs'. Sort by species.
  All these files have been already processed by "barapost.py". Perform "FAST5 untwisting".
  Results of "barapost.py" work are in directory 'prober_outdir':\n
  ./fastQA5-sorter.py -d dir_with_seqs -o outdir -r prober_outdir/ -s species -u""")
        # end if
    platf_depend_exit(0)
# end if

if "-v" in sys.argv[1:] or "--version" in sys.argv[1:]:
    print(__version__)
    platf_depend_exit(0)
# end if


from src.printlog import err_fmt, printl, printn, getwt, get_full_time
from src.filesystem import get_curr_res_dpath, OPEN_FUNCS, FORMATTING_FUNCS, is_gzipped

from re import search as re_search
from glob import glob
import os
import getopt

try:
    opts, args = getopt.gnu_getopt(sys.argv[1:], "hvr:d:o:s:q:m:ut:z:",
        ["help", "version", "taxannot-resdir=", "indir=", "outdir=",
         "sorting-sensitivity=", "min-ph33-qual=", "min-seq-len=",
         "untwist-fast5", "threads=", "gzip="])
except getopt.GetoptError as gerr:
    print( str(gerr) )
    platf_depend_exit(2)
# end try

from src.filesystem import is_fasta, is_fastq, is_fast5
is_fastqa = lambda f: is_fasta(f) or is_fastq(f)

from datetime import datetime
now = datetime.now().strftime("%Y-%m-%d %H.%M.%S")

# |== Default parameters: ==|
fq_fa_list = list() # input FASTQ and FASTA files paths
fast5_list = list() # input FAST5 files paths
tax_annot_res_dir = "barapost_result" # path to result TSV file generated by barapost.py
indir_path = None # path to input directory
outdir_path = "sorter_result_{}".format(now.replace(' ', '_')) # path to output directory
sens = "genus" # sorting sensitivity
min_qual = 10 # minimum mean read quality to keep
min_qlen = None # minimum seqeunce length to keep (unlimited by delault, see 'SeqLength' class definition)
untwist_fast5 = False # flag indicating whether to run 'FAST5-untwisting' or not
n_thr = 1 # number of threads to launch
compress = True # flag indicating whether to compress output files or not

# Add positional arguments to fq_fa_list and fast5_list
for arg in args:
    if not os.path.exists(arg):
        print(err_fmt("file does not exist:\n '{}'".format(os.path.abspath(arg))))
        platf_depend_exit(1)
    # end if
    if is_fastqa(arg):
        fq_fa_list.append( os.path.abspath(arg) )
    elif is_fast5(arg):
        fast5_list.append( os.path.abspath(arg) )
    else:
        print(err_fmt("invalid positional argument: '{}'".format(arg)))
        print("Only FAST(A/Q/5) files can be specified without a key in command line.")
        platf_depend_exit(1)
    # end if
    
# end for

for opt, arg in opts:

    if opt in ("-o", "--outdir"):
        outdir_path = os.path.abspath(arg)

    elif opt in ("-r", "--taxannot-resdir"):
        if not os.path.exists(arg):
            print(err_fmt("directory '{}' does not exist!".format(arg)))
            platf_depend_exit(1)
        # end if
        if not os.path.isdir(arg):
            print(err_fmt("'{}' is not a directory!".format(arg)))
            platf_depend_exit(1)
        # end if
        tax_annot_res_dir = os.path.abspath(arg)

    elif opt in ("-s", "--sorting-sensitivity"):
        if arg not in ("genus", "species"):
            print(err_fmt("invalid value specified with '-s' option!"))
            print("Available values: 'genus', 'species'")
            print("\nType for help:\n    ./fastQA5-sorter.py -h")
            platf_depend_exit(1)
        # end if
        sens = arg

    elif opt in ("-q", "--min-ph33-qual"):
        try:
            min_qual = float(arg)
            if min_qual < 0:
                raise ValueError
            # end if
        except ValueError:
            print(err_fmt("min Phred33 quality must be positive number!"))
            print("You've specified '{}'".format(arg))
            platf_depend_exit(1)
        # end try

    elif opt in ("-m", "--min-seq-len"):
        try:
            min_qlen = int(arg)
            if min_qlen < 0:
                raise ValueError
            # end if
        except ValueError:
            print(err_fmt("minimum length of the sequence must be positive integer number!"))
            print("You've specified '{}'".format(arg))
            platf_depend_exit(1)
        # end try

    elif opt in ("-u", "--untwist-fast5"):
        untwist_fast5 = True

    elif opt in ("-z", "--gzip"):
        if arg in ("true", "false"):
            compress = False if arg == "false" else True
        else:
            print(err_fmt("invalid value passed with '{}' option".format(opt)))
            print("Available values: 'true', 'false'")
            print("You have specified '{}'".format(arg))
            platf_depend_exit(1)
        # end if

    elif opt in ("-t", "--threasds"):
        try:
            n_thr = int(arg)
            if n_thr < 1:
                raise ValueError
            # end if
        except ValueError:
            print(err_fmt("number of threads must be positive integer number!"))
            platf_depend_exit(1)
        # end try
        if n_thr > len(os.sched_getaffinity(0)):
            print("""\nWarning! You have specified {} threads to use
  although {} are available.""".format(n_thr, len(os.sched_getaffinity(0))))
            error = True
            while error:
                reply = input("""\nPress ENTER to switch to {} threads,
  or enter 'c' to continue with {} threads,
  or enter 'q' to exit:>>""".format(len(os.sched_getaffinity(0)), n_thr))
                if reply in ("", 'c', 'q'):
                    error = False
                    if reply == "":
                        n_thr = len(os.sched_getaffinity(0))
                        print("\nNumber of threads switched to {}\n".format(n_thr))
                    elif reply == 'c':
                        pass
                    elif reply == 'q':
                        exit(0)
                    # end if
                else:
                    print("\nInvalid reply!\n")
                # end if
            # end while
        # end if
        import multiprocessing as mp

    elif opt in ("-d", "--indir"):
        if not os.path.exists(arg):
            print(err_fmt("directory '{}' does not exist!".format(arg)))
            platf_depend_exit(1)
        # end if
        
        if not os.path.isdir(arg):
            print(err_fmt("'{}' is not a directory!".format(arg)))
            platf_depend_exit(1)
        # end if
        indir_path = os.path.abspath(arg)

        fq_fa_list.extend(list( filter(is_fastqa, glob("{}{}*".format(indir_path, os.sep))) ))
        fast5_list.extend(list( filter(is_fast5, glob("{}{}*".format(indir_path, os.sep))) ))
    # end if
# end for

# Check if "prober result" directory is specified
if not os.path.exists(tax_annot_res_dir):
    print(err_fmt("directory '{}' does not exist!".format(tax_annot_res_dir)))
    if tax_annot_res_dir == "barapost_result":
        print("""Maybe, output directory generated by 'prober.py' hasn't been named 'barapost_result'
    and you have forgotten to specify '-r' option.""")
    platf_depend_exit(1)
    # end if
# end if

# If no FAST(A/Q/5) file have been specified
if len(fq_fa_list) == 0 and len(fast5_list) == 0:
    # If input directory was specified -- exit
    if not indir_path is None:
        print(err_fmt("no input FAST(Q/A/5) files found in the input directory.\n"))
        print("Input directory: '{}'".format(indir_path))
        platf_depend_exit(1)
    # If input directory was not specified -- look for FASTQ and FASTA files in current directory
    else:
        fq_fa_list.extend(list( filter(is_fastqa, glob("{}{}*".format(os.getcwd(), os.sep))) ))
        fast5_list.extend(list( filter(is_fast5, glob("{}{}*".format(os.getcwd(), os.sep))) ))
        if len(fq_fa_list) == 0 and len(fast5_list) == 0:
            print(err_fmt("no input FAST(Q/A/5) files are specified and there is no FAST(Q/A/5) file in working directory.\n"))
            platf_depend_exit(1)
        # end if
    # end if
# end if

num_files = len(fq_fa_list) + len(fast5_list)

if len(fq_fa_list) == 0 and not "-u" in sys.argv[1:] and not "--untwist-fast5" in sys.argv[1:]:
    print("\nWarning! Sorting FAST5 files in parallel doesn't give any profit.")
    print("Number of threads is switched to 1.")
    n_thr = 1
# end if

if len(fast5_list) == 0 and untwist_fast5:
    print("\nWarning! No FAST5 file has been given to sorter's input.")
    print("Therefore, '-u' ('--untwist-fast5') flag does not make any sense.")
    print("Ignoring it.")
    untwist_fast5 = False
# end if

# Sort input files in order to process them in alphabetical order
fq_fa_list.sort()
fast5_list.sort()

# Create output directory
if not os.path.isdir(outdir_path):
    try:
        os.makedirs(outdir_path)
    except OSError as oserr:
        print(err_fmt("unable to create result directory"))
        print("fastQA5-sorter just tried to create directory '{}' and crushed.".format(outdir_path))
        print("Reason: {}".format( str(oserr) ))
        platf_depend_exit(1)
    # end try
# end if


def get_checkstr(fast5_fpath):
    """
    Function returns string that will help fasQA5-sorter to find
        TSV file generated by prober and barapost while provessing FASTQ file
        that in turn is basecalled 'fast5_fpath'-file.
    
    Function first searches for ID given to file by programs like of MinKNOW.
    That is:
        1) sequence of 40 (I've seen 40, maybe there can be other number)
        latin letters in lower case interlaced with numbers;
        2) underscore;
        3) number of file within sequenator run;
    For example: file named "FAK94973_e6f2851ddd414655574208c18f2f51e590bf4b27_0.fast5"
        has checkstring "e6f2851ddd414655574208c18f2f51e590bf4b27_0".
    "FAK94973" is not regarding because it can be pruned by basecaller. For example, Guppy acts in this way.

    If no such distinctive string is found in FAST5 file name
        (file can be renamed by the user after sequensing)
        whole file name (except of the '.fast5' extention) is returned as checksting.

    :param fast5_fpath: path to FAST5 file meant to be processed;
    :type fast5_fpath: str;

    Returns checkstring described above.
    """

    try:
        # I'll lower the 40-character barrier down to 30 just in case.
        filename_payload = re_search(r"([a-zA-Z0-9]{30,}_[0-9]+)", fast5_fpath).group(1)
    except AttributeError:
        return os.path.basename(fast5_fpath).replace(".fast5", "")
    else:
        return filename_payload
    # end try
# end def get_checkstr


logfile_path = get_logfile_path("fastQA5-sorter", outdir_path)

printl(logfile_path, "\n |=== fastQA5-sorter.py (version {}) ===|\n".format(__version__))
printl(logfile_path, get_full_time() + "- Start working\n")

check_mark = "ok"

# Make sure that each file meant to be processed has it's directory with TSV result file
#    generated by prober and barapost.
printn("Primary validation...")
if not untwist_fast5:
    for fpath in fast5_list:

        # Get number of directories in 'tax_annot_res_dir' where results of current FAST5
        #    baraposting ar elocated.
        put_fast5_resdirs_num = len( glob("{}{}*{}*".format(tax_annot_res_dir, os.sep, get_checkstr(fpath))) )

        if put_fast5_resdirs_num == 1:
            continue # OK
        elif put_fast5_resdirs_num == 0: # there is no such a directory
            print(err_fmt("""directory that may be considered as valid for sorting of file
  '{}'\n    is not found in the directory '{}'""".format(fpath, tax_annot_res_dir)))
            print("Try running sorter with '-u' ('--untwist-fast5') flag.\n")
            platf_depend_exit(1)
        else: # there are multiple directories where prober-barapost results can be located
            print(err_fmt("multiple result directories match FAST5 file meant to be sorted"))
            print("  Please, contact the developer -- it is his mistake.\n")
            platf_depend_exit(1)
        # end if
    # end for
# end if

for fpath in fq_fa_list:
    # Validate new_dpath existance for FASTA and FASTQ files:
    if not os.path.isdir( get_curr_res_dpath(fpath, tax_annot_res_dir) ):
        print(err_fmt("prober result directory not found"))
        print("""Directory that should have contained results of taxonomic annotation of the following file:
  '{}' does not exist.""".format(os.path.basename(fpath)))
        print("Please, make sure that this file have been already processed by 'prober.py' and 'barapost.py'.")
        platf_depend_exit(1)
    # end if
# end for

print("\rPrimary validation... {}\n".format(check_mark))

is_fastQA5 = lambda f: True if not re_search(r".*\.(m)?f(ast)?(a|q|5)(\.gz)?$", f) is None else False

# Check if there are some results in output directory
if len( list( filter(is_fastQA5, os.listdir(outdir_path)) ) ) != 0:
    printl(logfile_path, "Attention! Output directory '{}' is not empty!".format(outdir_path))
    printl(logfile_path, "List of sequence-containing files in it:")
    for i, file in enumerate(filter(is_fastQA5, os.listdir(outdir_path))):
        printl(logfile_path, "  {}. '{}'".format(i+1, file))
    # end for
    print()
    
    invalid_reply = True
    while invalid_reply:
        reply = input("""Press ENTER to ovewrite all old sequence-containing files
    or enter 'r' to rename old directory and to write current results to a new one
    or enter 'a' to append new data to the existing one:>>""")

        if reply == "":
            invalid_reply = False

            for file in filter(is_fastQA5, os.listdir(outdir_path)):
                printl(logfile_path, "Removing '{}'".format( os.path.join(outdir_path, file) ))
                os.unlink( os.path.join(outdir_path, file) )
            # end for
            print()
            break
        elif reply == 'r':
            invalid_reply = False

            is_analog = lambda d: os.path.basename(outdir_path) in d
            num_analog_dirs = len( list(filter(is_analog, os.listdir(os.path.dirname(outdir_path)))) )
            
            try:
                printl(logfile_path, '\n' + getwt() + " - Renaming old directory:")
                new_name = outdir_path+"_old_"+str(num_analog_dirs)
                printl(logfile_path, "  '{}' --> '{}'".format(outdir_path, new_name))
                os.rename(outdir_path, new_name)
            except Exception as err:
                # Anything (and not only strings) can be passed to the function
                printl(logfile_path, err_fmt("directory '{}' cannot be renamed".format( outdir_path )))
                printl(logfile_path, str(err) + '\n')
                platf_depend_exit(1)
            # end try
            print()
        elif reply == 'a':
            invalid_reply = False
        else:
            print("Invalid reply!\n")
        # end if
    # end while
# end if

del is_fastQA5

if untwist_fast5:

    # Names of index files
    index_name = "fast5_to_tsvtaxann_idx"

    # Create index directory
    index_dirpath = os.path.join(tax_annot_res_dir, index_name) # name of directory that will contain indicies
    if not os.path.isdir(index_dirpath):
        try:
            os.makedirs(index_dirpath)
        except OSError as oserr:
            printl(logfile_path, err_fmt("cannot create index directory"))
            printl(logfile_path, "Directory that cannot be created: '{}'".format(index_dirpath))
            printl(logfile_path, "Reason: '{}'".format( str(oserr) ))
            platf_depend_exit(1)
        # end try
    # end if

    def whether_to_build_index():

        use_old_index = False

        if len(os.listdir(index_dirpath)) != 0:
            printl(logfile_path, "Attention! Index file created by '-u' (--untwist_fast5) option exists (left from previous run).")

            error = True

            while error:
                reply = input("""  Press ENTER to make new index file
      or enter 'u' to use old index file:>>""")
                if reply == "":
                    try:
                        for path in glob( os.path.join(index_dirpath, '*') ):
                            os.unlink(path)
                        # end for
                    except OSError as oserr:
                        printl(logfile_path, err_fmt("Cannot remove old index files!"))
                        printl(logfile_path,  str(oserr) )
                        platf_depend_exit(1)
                    # end try
                    error = False
                elif reply == 'u':
                    use_old_index = True
                    error = False
                else:
                    print("Invalid reply!\n")
                # end if
            # end while
            printl(logfile_path, "You have chosen to {} index file.\n".format("use old" if use_old_index else "make new"))
        # end if
        return use_old_index
    # end def whether_to_build_index
# end if


from src.spread_files_equally import spread_files_equally

# |===== Create output directory =====|
if not os.path.exists(outdir_path):
    try:
        os.makedirs(outdir_path)
    except Exception as err:
        printl(logfile_path, err_fmt("unable to create output directory!"))
        printl(logfile_path,  str(err) )
        platf_depend_exit(1)
    # end try
# end if



# |=== Module assembling ===|

# Here we are going to define different functions for different use cases:
#   parallel and single-thread procesing requires different functions that
#   performs writing to and sorting plain (FASTA, FASTQ) files.
# It is better to check number of threads once and define functions that will
#   be as strait-forward as possible rather than check conditions each time in a spaghetti-function.

FAST5_srt_module = None
QA_srt_module = None
utw_module = None

try:

    if len(fq_fa_list) != 0:
        if n_thr == 1:
            import src.sorter_modules.single_thread_QA as QA_srt_module
        else:
            import src.sorter_modules.parallel_QA as QA_srt_module
        # end if
    # end if


    if len(fast5_list) != 0:

        # Will be None if unwtisting is disabled and True/False otherwise
        use_old_index = None

        if untwist_fast5:
            use_old_index = whether_to_build_index()
            # We do not need this function if we do not make new index
            if not use_old_index:
                if n_thr == 1:
                    import src.sorter_modules.single_thread_FAST5_utwfunc as utw_module
                else:
                    import src.sorter_modules.parallel_FAST5_utwfunc as utw_module
                # end if
            # end if
        # end if

        if use_old_index is None:
            # If untwisting is disabled:
            import src.sorter_modules.single_thread_FAST5_srtfunc as FAST5_srt_module
        else:
            # If untwisting is enabled:
            import src.sorter_modules.single_thread_FAST5_srtfunc_utw as FAST5_srt_module
        # end if
    # end if
except ImportError as imperr:
    printl(logfile_path, err_fmt("module integrity is corrupted!"))
    printl(logfile_path, str(imperr))
    platf_depend_exit(1)
# end try


def get_tsv_taxann_lst(tax_annot_res_dir, index_name):
    """
    Function returns list of path to TSV files that contain taxonomic annotation.

    :param tax_annot_res_dir: path to '-r' directory;
    :type tax_annot_res_dir: str;
    :param index_name: basename of index file;
    :type index_name: str;
    """

    index_dirpath = os.path.join(tax_annot_res_dir, index_name) # name of directory that will contain indicies

    # Get all directories nested in 'tax_annot_res_dir'
    taxann_dir_lst = list(filter(lambda f: True if os.path.isdir(f) else False,
        glob( os.path.join(tax_annot_res_dir, "*") )))

    # Exclude "local_database" and "fast5_to_fastq_idx" from this list
    for dir_to_exclude in (index_name, "local_database"):
        ldb_dir_path = os.path.join(tax_annot_res_dir, dir_to_exclude)
        if ldb_dir_path in taxann_dir_lst:
            taxann_dir_lst.remove(ldb_dir_path)
        # end if
    # end for

    # Get path to TSV files containing taxonomy annotation info
    tsv_taxann_lst = list()
    for taxann_dir in taxann_dir_lst:
        if os.path.join(taxann_dir, "classification.tsv"):
            tsv_taxann_lst.append(os.path.join(taxann_dir, "classification.tsv"))
        # end if
    # end for

    return tsv_taxann_lst
# end def get_tsv_taxann_lst


# |===== Proceed =====|

printl(logfile_path, '-' * 30)
printl(logfile_path, " - Output directory: '{}';".format(outdir_path))
printl(logfile_path, " - Logging to '{}';".format(logfile_path))
printl(logfile_path, " - Sorting according to classification in directory '{}';".format(outdir_path))
printl(logfile_path, " - Sorting sensitivity: '{}';".format(sens))
printl(logfile_path, " - Minimum mean quality of a read to keep: {};".format(min_qual))
if not min_qlen is None:
    printl(logfile_path, " - Minimum length of a read to keep: {};".format(min_qlen))
# end if
printl(logfile_path, " - Threads: {};".format(n_thr))
if untwist_fast5:
    printl(logfile_path, " - \"FAST5 untwisting\" is enabled;")
# end if

s_letter = '' if num_files == 1 else 's'
printl(logfile_path, "\n {} file{} will be processed.".format( num_files, s_letter))
with open (logfile_path, 'a') as logfile:
    logfile.write("Here they are:\n")
    i = 1
    for path in fq_fa_list:
        logfile.write("    {}. '{}'\n".format(i, path))
        i += 1
    # end for
    for path in fast5_list:
        logfile.write("    {}. '{}'\n".format(i, path))
        i += 1
    # end for
# end with


# |=== Proceed "FAST5-untwisting" if enabled ===|

printl(logfile_path, '-' * 30 + '\n')

if untwist_fast5 and not use_old_index:

    printl(logfile_path, "{} - Untwisting started.".format(getwt()))
    printn(" Working...")

    tsv_taxann_lst = get_tsv_taxann_lst(tax_annot_res_dir, index_name)

    if n_thr == 1:
        for f5_path in fast5_list:
            utw_module.map_f5reads_2_taxann(f5_path, tsv_taxann_lst, tax_annot_res_dir, logfile_path)
            printl(logfile_path, "\r{} - File '{}' is processed.".format(getwt(), os.path.basename(f5_path)))
            printn(" Working...")
        # end for
    else:
        pool = mp.Pool(n_thr, initializer=utw_module.init_paral_utw,
            initargs=(mp.Lock(), mp.Lock(),))
        pool.starmap(utw_module.map_f5reads_2_taxann,
            [(sublist, tsv_taxann_lst, tax_annot_res_dir, logfile_path,) for sublist in spread_files_equally(fast5_list, n_thr)])
        pool.close()
        pool.join()
    # end if

    printl(logfile_path, "\r{} - Untwisting is completed.".format(getwt()))
    printl(logfile_path, "Index file that maps reads stored in input FAST5 files to\n  TSV files containing taxonomic classification is created.")
    printl(logfile_path, '-'*20+'\n')
# end if

if n_thr == 1 or len(fast5_list) != 0:
    from src.sorter_modules.launch import launch_single_thread_sorting
# end if

if n_thr != 1:
    from src.sorter_modules.launch import launch_parallel_sorting
# end if


# |=== Proceed sorting ===|

printl(logfile_path, "{} - Sorting started.".format(getwt()))
printn(" Working...")

res_stats = list()

if len(fast5_list) != 0:
    res_stats.extend(launch_single_thread_sorting(fast5_list,
        FAST5_srt_module.sort_fast5_file, tax_annot_res_dir, sens,
            min_qual, min_qlen, logfile_path))
# end if
if len(fq_fa_list) != 0:
    if n_thr != 1:
        res_stats.extend(launch_parallel_sorting(fq_fa_list,
            QA_srt_module.sort_fastqa_file, tax_annot_res_dir, sens, n_thr,
            min_qual, min_qlen, logfile_path))
    else:
        res_stats.extend(launch_single_thread_sorting(fq_fa_list,
            QA_srt_module.sort_fastqa_file, tax_annot_res_dir, sens,
            min_qual, min_qlen, logfile_path))
# end if

printl(logfile_path, "\r{} - Sorting is completed.\n".format(getwt()))

# Assign version attribute to '2.0' -- multiFAST5
if len(fast5_list) != 0:
    FAST5_srt_module.assign_version_2(fast5_list)
# end if

# Summarize statistics
seqs_pass = sum(map(lambda x: x[0], res_stats))
seqs_fail = sum(map(lambda x: x[1], res_stats))

from src.get_undr_sep_number import get_undr_sep_number


printl(logfile_path, "{} sequences have been processed.".format(get_undr_sep_number(seqs_pass + seqs_fail)))
if seqs_fail > 0:
    len_fmt_str = " and length ({} bp)".format(min_qlen) if not min_qlen is None else ""
    printl(logfile_path, "{} of them have passed quality (Q{}){} controle.".format(get_undr_sep_number(seqs_pass),
        int(min_qual), len_fmt_str))
# end if

fastqa_res_files = list(filter(is_fastqa, glob(os.path.join(outdir_path, '*'))))

# Exit now if there is nothing to compress
if len(fastqa_res_files) == 0 or not compress:
    printl(logfile_path, '\n'+ get_full_time() + "- Task is completed!\n")
    platf_depend_exit(0)
# end if

# Otherwise -- proceed gzipping

printl(logfile_path, "{} - Gzipping output files started".format(getwt()))

# GNU gzip utility is faster, but there can be presence of absence of it :)
gzip_util = "gzip"
util_found = False
for directory in os.environ["PATH"].split(os.pathsep):
    if os.path.isdir(directory) and gzip_util in os.listdir(directory):
        util_found = True
        break
    # end if
# end for

# Define function that will gzip files

if util_found:

    def gzip_func(fpaths):
        """Function that compresses output FASTA and FASTQ files with gzip utility.
        
        :param fpath: path to file to compress;
        :type fpath: str;
        """

        for fpath in fpaths:
            try:
                if not os.system("{} {}".format(gzip_util, fpath)) == 0:
                    raise OSError("Gzip error")
                # end if
            except OSError as oserr:
                printl(logfile_path, err_fmt("cannot gzip file '{}'".format(os.path.basename(fpath))))
                printl(logfile_path, "Reason: {}".format( str(oserr) ))
                # Try to gzip others -- continue loop
            else:
                printl(logfile_path, "{} - Gzipping '{}' completed".format(getwt(), os.path.basename(fpath)))
            # end try
        # end for
    # end def gzip_func
else:

    from shutil import copyfileobj as shutil_copyfileobj
    from gzip import open as open_as_gzip

    def gzip_func(fpaths):
        """Function that compresses output FASTA and FASTQ files with Python gzip and shutil modules.
        
        :param fpath: path to file to compress;
        :type fpath: str;
        """
        for fpath in fpaths:
            try:
                # form .fasta.gz file 'by hand'
                with open(fpath, 'rb') as fastqa_file, open_as_gzip(fpath+".gz", "wb") as faqgz_file:
                    shutil_copyfileobj(fastqa_file, faqgz_file)
                # end with
                os.unlink(fpath) # remove plain FASTA file
            except OSError as oserr:
                printl(logfile_path, err_fmt("cannot gzip file '{}'".format(os.path.basename(fpath))))
                printl(logfile_path, "Reason: {}".format( str(oserr) ))
                # Try to gzip others -- continue loop
            else:
                printl(logfile_path, "{} - Gzipping '{}' completed".format(getwt(), os.path.basename(fpath)))
            # end try
        # end for
    # end def gzip_func
# end if

if n_thr == 1: # single-thread compressing

    gzip_func(fastqa_res_files)

else: # compress in parallel
    
    pool = mp.Pool(n_thr)
    pool.starmap(gzip_func, [(sublist,) for sublist in spread_files_equally(fastqa_res_files, n_thr)])
    pool.close()
    pool.join()
# end if
printl(logfile_path, "{} - Gzipping output files completed".format(getwt()))

printl(logfile_path, '\n'+ get_full_time() + "- Task is completed!\n")
platf_depend_exit(0)