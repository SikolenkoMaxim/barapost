#!/usr/bin/env python3

# Version 1.0
# 22.08.2019 edition

# |===== Check python interpreter version =====|

from sys import version_info as verinf

if verinf.major < 3:#{
    print( "\nYour python interpreter version is " + "%d.%d" % (verinf.major, verinf.minor) )
    print("\tPlease, use Python 3!\a")
    # In python 2 'raw_input' does the same thing as 'input' in python 3.
    # Neither does 'input' in python2.
    raw_input("Press ENTER to exit:")
    exit(1)
#}

# Get start time
from datetime import datetime
now = datetime.now().strftime("%Y-%m-%d %H.%M.%S")
# -------------------

print("\n |=== fastQA_sorter.py (version 1.0) ===|\n\n")
# -------------------

from sys import platform

def platf_depend_exit(exit_code):#{
    """
    A function that asks to press ENTER on Windows
        and exits.

    :type exit_code: int;
    """
    if platform.startswith("win"):
        input("Press ENTER to exit:")
    exit(exit_code)
#}
# -------------------


from gzip import open as open_as_gzip
from re import search as re_search
import os
import getopt
from sys import argv
# -------------------


help_msg = """
DESCRIPTION:\n
 fastQA_forter.py -- script designed for sorting FASTQ and FASTAfiles processed by barapost.py.

 Requires result TSV file generated by "barapost.py" and FASTQ files processed by it.
 Therefore '-b' option is mandatory.

 - Separate FASTQ or FASTA files should be specified with -f(--infile) option (see EXAMPLES below).
 - If -d (--indir) option is specified, all FASTQ and FASTA files in directory specified by this option will be sorted.
 - If no separate FASTQ or FASTA files and not input directory is specified,
       fastQA_sorter will process all FASTQ and FASTA files in current directory.
--------------------------------

OPTIONS (* means mandatory option):\n
    -h (--help) --- show help message;\n
  * -b (--barapost-result) --- result TSV file generated by barapost.py;\n
    -f (--infile) --- input FASTQ of FASTA file (can be gzipped);\n
    -d (--indir) --- directory which contains FASTQ and/or FASTA files (files can be gzipped) meant to be sorted;\n
    -o (--outdir) --- output directory;\n
    -s (--sorting-sensitivity) --- sorting sensitivity,
        e.i. the lowest taxonomy rank that will be used in names of resut files;
        Available values: 'genus', 'species', 'strain'; Default is 'species'.
--------------------------------

EXAMPLES:\n
  1) Process one FASTQ file with default settings:\n
     ./fastq_sorter.py -f reads.fastq.gz -b test_megaBlast_result.tsv\n
  2) Process a FASTQ file and a FASTA file, place results in "outdir" directory:\n
     ./fastq_sorter.py -f reads_1.fastq.gz -f reads_2.fasta -o outdir -b test_megaBlast_result.tsv\n
  3) Process all FASTQ and FASTA files in directory named "dir_with_reads". Sort by genus:\n
     ./fastq_sorter.py -d dir_with_reads -o outdir -b test_megaBlast_result.tsv -s genus
"""
# -------------------


try:#{
    opts, args = getopt.getopt(argv[1:], "hb:f:d:o:s:", ["help", "barapost-result=", "indir=", "outdir=",
        "sorting-sensitivity="])
#}
except getopt.GetoptError as gerr:#{
    print( str(serr) )
    platf_depend_exit(2)
#}
# -------------------


is_fq_or_fa = lambda f: True if not re_search(r".*\.f(ast)?(a|q)(\.gz)?$", f) is None else False
fq_fa_paths = list() # input FASTQ files paths
barapost_res_path = None # path to result TSV file generated by barapost.py
indir_path = None # path to input directory
outdir_path = "fastQA_sorter_result_{}".format(now) # defalut value
sens = "species"

for opt, arg in opts:#{

    if opt in ("-h", "--help"):#{
        print(help_msg)
        platf_depend_exit(0)
    #}

    if opt in ("-f", "--infile"):#{
        if not os.path.exists(arg):#{
            print("\n\t\a!! - ERROR: file '{}' does not exist!".format(arg))
            platf_depend_exit(1)
        if not is_fq_or_fa(arg):#{
            print(" !! - Warning: file '{}' is not '.fastq' and not '.fasta'!".format(arg))
            platf_depend_exit(1)
        #}
        fq_fa_paths.append(arg)
    #}

    if opt in ("-d", "--indir"):#{
        if not os.path.exists(arg):#{
            print("\n\t\a!! - ERROR: directory '{}' does not exist!".format(arg))
            platf_depend_exit(1)
        #}
        if not os.path.isdir(arg):#{
            print("\n\t\a!! - ERROR: '{}' is not a directory!".format(arg))
            platf_depend_exit(1)
        #}
        indir_path = os.path.abspath(arg)
    #}

    if opt in ("-o", "--outdir"):#{
        outdir_path = os.path.abspath(arg)
    #}

    if opt in ("-b", "--barapost-result"):#{
        if not os.path.exists(arg):#{
            print("\n\t\a!! - ERROR: file '{}' does not exist!".format(arg))
            platf_depend_exit(1)
        #}
        barapost_res_path = os.path.abspath(arg)
    #}

    if opt in ("-s", "--sorting-sensitivity"):#{
        if arg not in ("genus", "species", "strain"):#{
            print("\n\t\a!!- ERROR: invalid value specified by '-s' option!\n")
            print("Available values: 'genus', 'species', 'strain'")
            print("\nType for help:\n    ./fastQA_forter.py -h")
            platf_depend_exit(1)
        #}
        sens = arg
    #}
#}

# Check if result TSV file generated by barapost.py is specified
if barapost_res_path is None:#{
    print("\n\t\a!! - ERROR: '-b' option is mandatory!\n")
    print(help_msg)
    platf_depend_exit(1)
#}

# Collect FASTQ and FASTA files from input directory
if indir_path is not None:#{
    indir_fastqs = list( filter(is_fq_or_fa, os.listdir(indir_path)) )
    fq_fa_paths.extend(indir_fastqs)
#}

# If no FASTQ or FASTA file have been found
if len(fq_fa_paths) == 0:#{
    # If input directory was specified -- exit
    if not indir_path is None:#{
        print("\n\t\a !! - ERROR: no input FASTQ or FASTA files specified or there is no FASTQ or FASTA files in the input directory.\n")
        platf_depend_exit(1)
    #}
    # If input directory was not specified -- look for FASTQ and FASTA files in current directory
    else:#{
        currdir_fastqs = list( filter(is_fq_or_fa, os.listdir('.')) )
        fq_fa_paths.extend(currdir_fastqs)
    #}
#}

del help_msg # we do not need this large string any more

print("\n Following files will be processed:")
for i, path in enumerate(fq_fa_paths):#{
    print("\t{}. {}".format(i+1, path))
#}
print('-'*20 + '\n')


# |=== Configure dictionary containing information generated by barapost.py ===|
resfile_lines = dict()
with open(barapost_res_path, 'r') as brpst_resfile:#{

    brpst_resfile.readline() # pass the head of the table
    line = brpst_resfile.readline().strip() # get the first informative line

    while line is not "":#{
        read_name = line.split('\t')[0]
        hit_name = line.split('\t')[1]
        resfile_lines[read_name] = hit_name

        line = brpst_resfile.readline().strip() # get next line
    #}
#}


# |===== Get sorting sensitivity if it is not specified=====|

if sens is None:#{

    while sens is None:#{
        sens = input("""
Please, specify sensitivity of sorting -- choose the taxonomy level to classify by:
1. Genus.
2. Species.
3. Strain.
This taxonomy level (actual organisms' names, sure) will be used in names of resut files.
Enter a number (1, 2 or 3):>> """)
        # Check if entered value is integer number. If no, give another attempt.
        try:#{
            sens = int(sens)
            if sens < 1 or sens > 3:#{ Check if input number is in [1, 3]
                print("\n\tNot a valid number entered!\a\n" + '~'*20)
                sens = None
            #}
            else:#{
                print("You have chosen number "+ str(sens) + '\n')
                print('~' * 20 + '\n')

                if sens is 1:
                    sens = "genus"
                elif sens is 2:
                    sens = "species"
                else:
                    sens = "strain"
            #}
        #}
        except ValueError:#{
            print("\nNot an integer NUMBER entered!\a\n" + '~'*20)
            sens = None
        #}
    #}
#}

print(" Reads will be sorted by {}".format(sens))
print('-'*20+'\n')

#                      Genus    species                   strain name and anything after it
hit_name_pattern = r"^[A-Z][a-z]+_[a-z]*(sp\.)?(phage)?_(strain_)?.+$"


def format_taxonomy_name(hit_name, sens):#{
    """
    Function formats taxonomy name according to chosen sensibiliry of sorting.
    :param hit_name: full_fit_name_of_the_subject_sequence;
    :type hit_name: str;
    :param sens: sensibility returned by 'get_classif_sensibility()' function.
        It's value can be one of the following strings: "genus", "sprcies", "strain";
    :type sens: str;
    Returns formatted hit name of 'str' type;
    """

    # If structure of hit name is strange
    if re_search(hit_name_pattern, hit_name.strip()) is None:#{
        print("\n\tAttention!")
        print("Hit name '{}' has structure that hasn't been anticipated by the developer.".format(hit_name))
        print("This name migth be formatted incorrectly.")
        print("Therefore, full name ({}) will be used.".format(hit_name.strip()))
        print("Contact the developer -- send this name to him.")

        return hit_name.strip().replace(' ', '_')   # return full name
    #}

    taxa_name = hit_name.partition(',')[0]
    taxa_splitnames = taxa_name.strip().split('_')

    # If hit is a phage sequence
    if taxa_splitnames[1] == "phage":#{
        # Assumming that the man who sortes by genus or species isn't interested in phage strain name
        if sens == "genus" or sens == "species":
            return '_'.join( [taxa_splitnames[0], taxa_splitnames[1]] ) # return "<Host_name> phage"
        else:
            return taxa_name.replace(' ', '_')   # return full name if we sort by strain
    #}

    if sens == "genus":#{
        return taxa_splitnames[0] # return genus
    #}
    elif sens == "species":#{
        if taxa_splitnames[1] == "sp.":#{ if species is not specified
            return taxa_name.replace(' ', '_')   # return full name
        #}
        else:#{
            return '_'.join( [taxa_splitnames[0], taxa_splitnames[1]] ) # return genus and species
        #}
    #}
    elif sens == "strain":#{
        return taxa_name.replace(' ', '_')   # return full name
    #}

    # Execution should not reach here
    raise Exception("Taxonomy name formatting error!")
#}


# |===== Format taxonomy names =====|
for read_name in resfile_lines.keys():#{
    resfile_lines[read_name] = format_taxonomy_name(resfile_lines[read_name], sens)
#}


def read_fastq_record(read_file):#{
    """
    :param read_file: file instance of FASTQ file to retrieve reads from;
    :type fasta_file: _io.TextIOWrapper or gzip.GzipFile;

    Returns dictionary of the following structure:
    {
        "seq_id": ID_of_read,
        "seq": sequence_itself,
        "opt_id": the_third_line,
        "qual_line": quality_line
    }
    """

    fastq_rec = dict()

    try:#{
        fastq_rec = {                    #read all 4 lines of fastq-record
            "seq_id": read_file.readline(),
            "seq": read_file.readline(),
            "opt_id": read_file.readline(),
            "qual_line": read_file.readline()
        }
    #}
    except Exception as err:#{
        print_red("\nAn error occured while reading from infile")
        print( str(err) )
        platf_depend_exit(1)
    #}

    return fastq_rec
#}


def read_fasta_record(read_file):#{
    """
    :param read_file: file instance of FASTA file to retrieve reads from;
    :type fasta_file: _io.TextIOWrapper or gzip.GzipFile;

    Returns dictionary of the following structure:
    {
        "seq_id": ID_of_read,
        "seq": sequence_itself
    }
    """

    fasta_rec = dict()

    try:#{
        fasta_rec = {                    #read all 2 lines of FASTA-record
            "seq_id": read_file.readline(),
            "seq": read_file.readline()
        }
    #}
    except Exception as err:#{
        print_red("\nAn error occured while reading from infile")
        print( str(err) )
        platf_depend_exit(1)
    #}

    return fasta_rec
#}


def write_fastq_record(outfile_path, fastq_record):#{
    """
    :param outfile: file, which data from fastq_record is written in
    :type outfile: _io.TextIOWrapper
    :param fastq_record: dict of 4 elements. Elements are four corresponding lines of FASTQ
    :type fastq_record: dict<str: str>

    Returns None
    """
    try:#{
        with open_as_gzip(outfile_path, 'ab') as sorted_file:
            sorted_file.write(bytes(fastq_record["seq_id"], "utf-8"))
            sorted_file.write(bytes(fastq_record["seq"], "utf-8"))
            sorted_file.write(bytes(fastq_record["opt_id"], "utf-8"))
            sorted_file.write(bytes(fastq_record["qual_line"], "utf-8"))
    #}
    except Exception as exc:#{
        print_red("\nAn error occured while writing to outfile")
        print( str(exc) )
        platf_depend_exit(1)
    #}
#}


def write_fasta_record(outfile_path, fasta_record):#{
    """
    :param outfile: file, which data from fasta_record is written in
    :type outfile: _io.TextIOWrapper
    :param fasta_record: dict of 2 elements. Elements are four corresponding lines of FASTA
    :type fasta_record: dict<str: str>

    Returns None
    """
    try:#{
        with open_as_gzip(outfile_path, 'ab') as sorted_file:
            sorted_file.write(bytes(fasta_record["seq_id"], "utf-8"))
            sorted_file.write(bytes(fasta_record["seq"], "utf-8"))
    #}
    except Exception as exc:#{
        print_red("\nAn error occured while writing to outfile")
        print( str(exc) )
        platf_depend_exit(1)
    #}
#}


is_gzipped = lambda f: True if f.endswith(".gz") else False
OPEN_FUNCS = (open, open_as_gzip)


# |===== Create output directory =====|
if not os.path.exists(outdir_path):#{
    try:#{
        os.makedirs(outdir_path)
    #}
    except Exception as err:#{
        print("\n\a\t!! - ERROR: unable to create output directory!")
        print( str(err) )
        platf_depend_exit(1)
    #}
#}


LINES_PER_READ_FASTQ = 4
LINES_PER_READ_FASTA = 2
is_fastq = lambda f: True if not re_search(r".*\.fastq(\.gz)?$", f) is None else False
num_files = len(fq_fa_paths)

for j, fq_fa_path in enumerate(fq_fa_paths):#{
    
    # Prune name of source FASTQ or FASTA file
    source_path_pruned = os.path.basename(fq_fa_path) # get rid of absolute path
    source_path_pruned = source_path_pruned.partition(".fast")[0] # get rid of extention

    how_to_open = OPEN_FUNCS[ is_gzipped(fq_fa_path) ] # get ready to open gzipped files
    lines_format = LINES_PER_READ_FASTQ if is_fastq(fq_fa_path) else LINES_PER_READ_FASTA
    num_reads = int (sum(1 for line in how_to_open(fq_fa_path)) / lines_format) # count number of reads in file

    # Get function that will read one record -- FASTQ of FASTA, in dependence of your file
    read_fun = read_fastq_record if is_fastq(fq_fa_path) else read_fasta_record
    # Get function that will write one record -- FASTQ of FASTA, in dependence of your file
    write_fun = write_fastq_record if is_fastq(fq_fa_path) else write_fasta_record
    
    with how_to_open(fq_fa_path) as source_fastq_file:#{

        for _ in range(num_reads):#{

            fastq_rec = read_fun(source_fastq_file) # get FASTQ or FASTA record
            read_name = fastq_rec["seq_id"].partition(' ')[0][1:] # get ID of the read

            try:#{
                hit_name = resfile_lines[read_name] # find hit corresponding to tis read
            #}
            except KeyError:#{
                print("\n\t\a !! - Warning: read '{}' not found in '{}' result file".format(read_name, barapost_res_path))
                print("Make sure that this read has been already baraposted.")
                continue
            #}
            # If read is found in TSV file:
            else:#{
                # Get name of resilt FASTQ file to write this read in
                sorted_file_path = os.path.join(outdir_path, "{}_{}.fast{}.gz".format(hit_name, source_path_pruned,
                    'q' if is_fastq(fq_fa_path) else 'a'))
                write_fun(sorted_file_path, fastq_rec) # write current read to sorted file
            #}
        #}
    #}

    print("\n File {}/{} '{}' is sorted".format(j+1, num_files, fq_fa_path))
    print('~'*20+'\n')
#}

print("Task has been successfully completed!")
platf_depend_exit(0)