#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Version 2.8.c
# 10.10.2019 edition

# |===== Check python interpreter version =====|

from sys import version_info as verinf

if verinf.major < 3:
    print( "\nYour python interpreter version is " + "%d.%d" % (verinf.major, verinf.minor) )
    print("   Please, use Python 3!\a")
    # In python 2 'raw_input' does the same thing as 'input' in python 3.
    # Neither does 'input' in python2.
    raw_input("Press ENTER to exit:")
    exit(1)
# end if

print("\n |=== fastQA-sorter-v2-8d.py ===|\n")

def err_fmt(text):
    """Function for configuring error messages"""
    return "\n   \a!! - ERROR: " + text + '\n'
# end def print_error

from sys import stdout as sys_stdout
def printn(text):
    """
    Function prints text to the console without adding '\\n' in the end of the line.
    Why not just to use 'print(text, end="")'?
    In order to display informative error message if Python 2.X is launched
        instead if awful error traceback.
    """
    sys_stdout.write(text)
# end def printn

# |===== Stuff for dealing with time =====|

from time import time, strftime, localtime, sleep, gmtime
start_time = time()


def get_work_time():
    return strftime("%H:%M:%S", gmtime( time() - start_time ))
# end def get_work_time


# Get start time
from datetime import datetime
now = datetime.now().strftime("%Y-%m-%d %H.%M.%S")
# -------------------

from sys import platform

def platf_depend_exit(exit_code):
    """
    A function that asks to press ENTER on Windows
        and exits.

    :type exit_code: int;
    """
    if platform.startswith("win"):
        input("Press ENTER to exit:")
    # end if
    exit(exit_code)
# end def platf_depend_exit


from gzip import open as open_as_gzip
from re import search as re_search
from glob import glob
import os
import getopt
from sys import argv
from sys import intern
# -------------------

help_msg = """
DESCRIPTION:\n
fastQA-sorter-v2-8d.py -- this program is designed for sorting (dividing into separate files)
    FASTQ and FASTA files processed by "barapost-v3-5b.py".\n
Moreover, it can sort FAST5 files according to taxonomical annotation of FASTQ files,
    that are result of basecalling these FAST5 files. Fro details, see README.md
    on github page: https://github.com/masikol/barapost\n
"fastQA-sorter-v2-8d.py" is meant to be used just after "barapost-v3-5b.py".
----------------------------------------------------------\n
Default parameters:\n
- all FASTQ, FASTA and FAST5 files in current directory will be processed;
- sorting sensitivity (see '-s' option): 'genus';
- output directory ('-o' option): directory named '"fastQA_sorter_result_<date_and_time_of_run>"''
  nested in current directory;
----------------------------------------------------------\n
Files that you want 'fastQA-sorter-v2-8d.py' to process should be
    specified as positional arguments (see EXAMPLE #2 below).
Wildcards do work: './fastQA-sorter-v2-8d.py my_directory/*'' will process all files in 'my_directory'.
----------------------------------------------------------\n
OPTIONS:\n
    -h (--help) --- show help message;\n
    -r (--prober-result-dir) --- result directory genearted by script 'prober.py'
        This is directory specified to 'prober.py' by '-o' option.
        Default value is "prober_result", since it is the default name of
        output directory generated by "prober.py".
    -d (--indir) --- directory which contains FAST(Q/A/5) files
        (FASTQ and FASTA files can be gzipped) meant to be sorted;\n
    -o (--outdir) --- output directory;\n
    -s (--sorting-sensitivity) --- sorting sensitivity,
        i.e. the lowest taxonomy rank that will be used in names of resut files;
        Available values: 'genus', 'species', 'strain'; Default is 'genus'.\n
    -q (--min-ph33-qual) --- minimum mean Phred33 quality of a read to keep;
        Reads of lower quality will be ignored;
        Default value: 20;
----------------------------------------------------------\n
EXAMPLES:\n
  1. Process all FASTA and FASTQ files in working directory with default settings:\n
    ./fastQA-sorter-v2-8d.py\n
  2. Process all files in the working directory that start with "some_my_fastq".
     Ignore reads with mean Phred33 quality < 15. The rest of settings are default:\n
     ./fastQA-sorter-v2-8d.py some_my_fastq* -q 15\n
  2. Process one FASTQ file with default settings.
     File 'reads.fastq' has been already processed by "barapost-v3-5b.py".
     Results of "barapost-v3-5b.py" work are in directory 'prober_outdir':\n
     ./fastQA-sorter-v2-8d.py reads.fastq.gz -r prober_outdir/\n
  3. Process a FASTQ file and a FASTA file, place results in 'outdir' directory.
     Files 'reads.fastq.gz' and 'another_sequences.fasta' have been already processed by "barapost-v3-5b.py".
     Results of "barapost-v3-5b.py" work are in directory 'prober_outdir':\n
     ./fastQA-sorter-v2-8d.py reads_1.fastq.gz some_sequences_2.fasta -o outdir -r prober_outdir/\n
  4. Process all FASTQ and FASTA files in directory named 'dir_with_seqs'. Sort by genus.
     All these files have been already processed by "barapost-v3-5b.py".
     Results of "barapost-v3-5b.py" work are in directory 'prober_outdir':\n
     ./fastQA-sorter-v2-8d.py -d dir_with_seqs -o outdir -r prober_outdir/ -s genus
"""

try:
    opts, args = getopt.gnu_getopt(argv[1:], "hr:d:o:s:q:", ["help", "prober-result-dir=", "indir=", "outdir=",
        "sorting-sensitivity=", "min-ph33-qual="])
except getopt.GetoptError as gerr:
    print( str(gerr) )
    platf_depend_exit(2)
# end try

is_fastQA5 = lambda f: True if not re_search(r".*\.(m)?f(ast)?(a|q|5)(\.gz)?$", f) is None else False
fq_fa_list = list() # input FASTQ files paths
prober_res_dir = "prober_result" # path to result TSV file generated by barapost-v3-5b.py
indir_path = None # path to input directory
outdir_path = "fastQA_sorter_result_{}".format(now.replace(' ', '_')) # defalut value
sens = "genus" # default value
min_ph33_qual = 20

# This varible will be True if at least one FAST5 file is meant to be processed.
# It is necessary in order not to import 'h5py' module if it is not needed.
fast5_in_inp_files = False

# Add positional arguments to fq_fa_list
for arg in args:
    if not os.path.exists(arg) or not is_fastQA5(arg):
        print(err_fmt("invalid positional argument: '{}'".format(arg)))
        print("Only FAST(A/Q/5) files can be specified without a key in command line.")
        platf_depend_exit(1)
    # end if
    fq_fa_list.append( os.path.abspath(arg) )
# end for


for opt, arg in opts:

    if opt in ("-h", "--help"):
        print(help_msg)
        platf_depend_exit(0)
    # end if

    if opt in ("-f", "--infile"):
        if not os.path.exists(arg):
            print(err_fmt("file '{}' does not exist!".format(arg)))
            platf_depend_exit(1)
        # end if
        if not is_fastQA5(arg):
            print(err_fmt("file '{}' is not either '.fastq', '.fasta' or '.fast5'".format(arg)))
            platf_depend_exit(1)
        # end if
        fq_fa_list.append(os.path.abspath(arg))
    # end if

    if opt in ("-d", "--indir"):
        if not os.path.exists(arg):
            print(err_fmt("directory '{}' does not exist!".format(arg)))
            platf_depend_exit(1)
        # end if
        
        if not os.path.isdir(arg):
            print(err_fmt("'{}' is not a directory!".format(arg)))
            platf_depend_exit(1)
        # end if
        indir_path = os.path.abspath(arg)

        fq_fa_list.extend(list( filter(is_fastQA5, glob("{}{}*".format(indir_path, os.sep))) ))
    # end if

    if opt in ("-o", "--outdir"):
        outdir_path = os.path.abspath(arg)
    # end if

    if opt in ("-r", "--prober-result-dir"):
        if not os.path.exists(arg):
            print(err_fmt("directory '{}' does not exist!".format(arg)))
            platf_depend_exit(1)
        # end if
        if not os.path.isdir(arg):
            print(err_fmt("'{}' is not a directory!".format(arg)))
            platf_depend_exit(1)
        # end if
        prober_res_dir = arg
    # end if

    if opt in ("-s", "--sorting-sensitivity"):
        if arg not in ("genus", "species", "strain"):
            print(err_fmt("invalid value specified by '-s' option!\n"))
            print("Available values: 'genus', 'species', 'strain'")
            print("\nType for help:\n    ./fastQA_sorter-v2-8d.py -h")
            platf_depend_exit(1)
        # end if
        sens = arg
    # end if

    if opt in ("-q", "--min-ph33-qual"):
        try:
            min_ph33_qual = float(arg)
            if min_ph33_qual < 0:
                raise ValueError
            # end if
        except ValueError:
            print(err_fmt("min Phred33 quality must be positive number!"))
            print("You've specified '{}'".format(arg))
            platf_depend_exit(1)
        # end try
    # end if
# end for

# Check if "prober result" directory is specified
if not os.path.exists(prober_res_dir):
    print(err_fmt("file '{}' does not exist!".format(prober_res_dir)))
    if prober_res_dir == "prober_result":
        print("""Maybe, output directory generated by 'prober.py' hasn't been named 'prober_result'
    and you have forgotten to specify '-r' option.""")
    platf_depend_exit(1)
    # end if
# end if

# If no FAST(A/Q/5) file have been found
if len(fq_fa_list) == 0:
    # If input directory was specified -- exit
    if not indir_path is None:
        print(err_fmt("no input FAST(Q/A/5) files specified OR there is no FAST(Q/A/5) files in the input directory.\n"))
        platf_depend_exit(1)
    # If input directory was not specified -- look for FASTQ and FASTA files in current directory
    else:
        fq_fa_list.extend(list(filter( is_fastQA5, glob("{}{}*".format(os.getcwd(), os.sep)) )))
    # end if
# end if

fq_fa_list.sort() # sort list of input files in order to process them in alphabetical order

# Create output directory
if not os.path.isdir(outdir_path):
    try:
        os.makedirs(outdir_path)
    except OSError as oserr:
        print(err_fmt("unable to create result directory"))
        print( str(oserr) )
        print("Prober just tried to create directory '{}' and crushed.".format(outdir_path))
        platf_depend_exit(1)
    # end try
# end if


def get_checkstr(fast5_fpath):
    """
    Function returns string that will help fasQA5-sorter to find
        TSV file generated by prober and barapost while provessing FASTQ file
        that in turn is basecalled 'fast5_fpath'-file.
    
    Function first searches for ID given to file by programs like of MinKNOW.
    That is:
        1) sequence of 41 (I've seen 41, maybe there can be other number)
        latin letters in lower case interlaced with numbers;
        2) underscore;
        3) number of file within sequenator run;
    For example: file named "FAK94973_e6f2851ddd414655574208c18f2f51e590bf4b27_0.fast5"
        has checkstring "e6f2851ddd414655574208c18f2f51e590bf4b27_0".
    "FAK94973" is not regarding because it can be pruned by basecaller. For example, Guppy acts in this way.

    If no such distinctive string is found in FAST5 file name
        (file can be renamed by the user after sequensing)
        whole file name (except of the '.fast5' extention) is returned as checksting.

    :param fast5_fpath: path to FAST5 file meant to be processed;
    :type fast5_fpath: str;

    Returns checkstring described above.
    """

    try:
        # I'll lower the 41-character barrier down to 30 just in case.
        filename_payload = re_search(r"([a-z0-9]{30,}_[0-9]+)", fast5_fpath).group(1)
    except AttributeError:
        return os.path.basename(fast5_fpath).replace(".fast5", "")
    else:
        return filename_payload
    # end try
# end def get_checkstr

# Make sure that each FAST5 file meant to be processed has it's directory with TSV result file
#    generated by prober and barapost.
for fpath in fq_fa_list:

    if fpath.endswith("fast5"):

        fast5_in_inp_files = True # signal for 'h5py' impoirting

        # Get number of directories in 'prober_res_dir' where results of current FAST5
        #    baraposting ar elocated.
        put_fast5_resdirs_num = len( glob("{}{}*{}*".format(prober_res_dir, os.sep, get_checkstr(fpath))) )

        if put_fast5_resdirs_num == 1:
            continue # OK
        elif put_fast5_resdirs_num == 0: # there is no such a directory
            print(err_fmt("""directory that may be considered as valid for sorting of file
    '{}'\n    is not found in the directory '{}'""".format(fpath, prober_res_dir)))
            print("\nTo SOLVE this issue, please follow these steps:\n")
            print("""  1. Make sure that FASTQ file that is the result of
'{}'\n  basecaling has been processed by 'prober-v1-12c.py' and 'barapost-v3-5b.py'.
Then try to sort this FAST5 file again.\n""".format(fpath))
            print("""  2. If you are sure that step 1 doesn't work for you,
but this error still occurs, then you should make sure that
results of processing this FASTQ file by programs mentioned above are located in the directory '{}'.
Then try to sort this FAST5 file again.\n""".format(prober_res_dir))
            print("""  3. If you are sure that steps 1 and 2 do not work for you,
but this error still occurs, then you should make sure that
names of corresponding FAST5 and FASTQ files are "analoguous".
Frankly speaking, make sure that you have NOT renamed FASTQ file after basecalling.
For the full definition of "analoguous" FAST5 and FASTQ files see REAMDE file in Barapost repository:
https://github.com/masikol/barapost
Then try to sort this FAST5 file again.\n""")
            print("""  4. If you are sure that steps 1, 2 and 3 do not work for you,
but this error still occurs, then you should contact the developer.\n""")
            platf_depend_exit(1)
        else: # there are multiple directories where prober-barapost results can be located
            print(err_fmt("multiple result directories match FAST5 file meant to be sorted"))
            print("  Please, contact the developer -- it is his mistake.\n")
            platf_depend_exit(1)
        # end if
    # end if
# end for


del help_msg # we do not need this large string object any more

# Try to import 'h5py' if at least FAST5 file is meant to be specified.
if fast5_in_inp_files:
    try:
        import h5py
    except ImportError as imperr:
        print(err_fmt("package 'h5py' is not installed"))
        print( "Exact error description given by the interpreter: {}".format(str(imperr)) )
        print("\n  'h5py' package is necessary for FAST5 files sorting.")
        print("  Please, install it (e.g. 'pip3 install h5py').")
        print("  Tip for Linux users: you may need to install 'libhdf5-dev' with your packet manager first and then go to pip.")
        platf_depend_exit(1)
    # end try
# end if


# There some troubles with file extention on Windows, so let's make a .txt file for it:
log_ext = ".log" if not platform.startswith("win") else ".txt"
logfile_path = os.path.join(outdir_path, "fastQA-sorter_log_{}{}".format(strftime("%d-%m-%Y_%H-%M-%S", localtime(start_time)), log_ext))
logfile = open(logfile_path, 'w')

logfile.write((" |=== fastQA-sorter-v2-8d.py ===|\n\n"))

def printl(text=""):
    """
    Function for printing text to console and to log file.
    """
    print(text)
    logfile.write(str(text).strip('\r') + '\n')
    logfile.flush()
# end def printl

# Check if there are some results in output directory
if len( list( filter(is_fastQA5, os.listdir(outdir_path)) ) ) != 0:
    printl("Attention! Ouput directory '{}' is not empty!".format(outdir_path))
    printl("List of sequence-containing files in it:")
    for i, file in enumerate(filter(is_fastQA5, os.listdir(outdir_path))):
        printl("  {}. '{}'".format(i+1, file))
    # end for
    print()
    
    invalid_reply = True
    while invalid_reply:
        reply = input("""Press ENTER to ovewrite all old sequence-containing files
    or enter 'r' to rename old directory and to write current results to a new one:>>""")

        if reply == "":
            invalid_reply = False

            for file in filter(is_fastQA5, os.listdir(outdir_path)):
                printl("Removing '{}'".format( os.path.join(outdir_path, file) ))
                os.unlink( os.path.join(outdir_path, file) )
            # end for
            print()
            break
        elif reply == 'r':
            invalid_reply = False

            is_analog = lambda d: os.path.basename(outdir_path) in d
            num_analog_dirs = len( list(filter(is_analog, os.listdir(os.path.dirname(outdir_path)))) )
            
            try:
                printl('\n' + get_work_time() + " - Renaming old directory:")
                new_name = outdir_path+"_old_"+str(num_analog_dirs)
                printl("  '{}' --> '{}'".format(outdir_path, new_name))
                os.rename(outdir_path, new_name)
            except Exception as err:
                # Anything (and not only strings) can be passed to the function
                printl(err_fmt("directory '{}' cannot be renamed".format( outdir_path )))
                printl( str(err) + '\n')
                platf_depend_exit(1)
            # end try
            print()
        else:
            print("Invalid reply!\n")
        # end if
    # end while
# end if

#                      Genus    species                   strain name and anything after it
hit_name_patt = r"[A-Z][a-z]+_[a-z]*(sp\.)?(phage)?_(strain_)?.+$"
# There is an accession number in the beginning of local FASTA file
local_name_hit_patt = r"OWN_SEQ_[0-9]+_"
# Pattern that will match ID of seqeunce in FASTA file generated by SPAdes
spades_patt = r"(NODE)_([0-9]+)"
# Pattern that will match ID of seqeunce in FASTA file generated by a5
a5_patt = r"(scaffold)_([0-9]+)"
# Pattern that will match file path in sequence ID
path_patt = r"\(_(.+)_\)"


def format_taxonomy_name(hit_name, sens):
    """
    Function formats taxonomy name according to chosen sensibiliry of sorting.
    :param hit_name: full_fit_name_of_the_subject_sequence;
    :type hit_name: str;
    :param sens: sensibility returned by 'get_classif_sensibility()' function.
        It's value can be one of the following strings: "genus", "sprcies", "strain";
    :type sens: str;
    Returns formatted hit name of 'str' type;
    """

    # This string can be edited in this funtion, original hei name will be kapt intact
    modif_hit_name = hit_name.strip()

    # If there is no hit -- we are sure what to do!
    if modif_hit_name == "No significant similarity found":
        return "unknown"
    # end if

    # Check if hit is a sequence from SPAdes or a5 assembly:
    spades_match_obj = re_search(spades_patt, modif_hit_name)
    a5_match_obj = re_search(a5_patt, modif_hit_name)

    for match_obj in (spades_match_obj, a5_match_obj):

        # If hit is a sequence from SPAdes or a5 assembly
        if not match_obj is None:

            # Find path to file with assembly:
            assm_path = re_search(path_patt, modif_hit_name).group(1)

            node_or_scaff = match_obj.group(1) # get word "NODE" or "scaffold"
            node_scaff_num = match_obj.group(2) # get it's number

            # SPAdes generate "NODEs"
            if node_or_scaff == "NODE":
                assmblr_name = "SPAdes"
            # a5 generates "scaffolds"
            elif node_or_scaff == "scaffold":
                assmblr_name = "a5"
            # There cannot be enything else
            else:
                print(err_fmt("signature of seq id from assembly not recognized: '{}'".format(hit_name)))
                platf_depend_exit(1)
            # end if

            # Include file path to sorted file name
            # Replace path separetor with underscore in order not to held a bacchanalia in file system.
            if assm_path is not None:
                if sens == "genus":
                    # Return only path and "NODE" in case of SPAdes and "scaffold" in case of a5
                    return '_'.join( (assmblr_name, "assembly", assm_path.replace(os.sep, '_'), node_or_scaff) )
                else:
                    # Return path and "NODE_<N>" in case of SPAdes and "scaffold_<N>" in case of a5
                    return '_'.join( (assmblr_name, "assembly", assm_path.replace(os.sep, '_'), node_or_scaff,
                        node_scaff_num) )
                # end if
            else:
                if sens == "genus":
                    # Return only "NODE" in case of SPAdes and "scaffold" in case of a5
                    return assmblr_name + "_assembly_" + node_or_scaff
                else:
                    # Return "NODE_<N>" in case of SPAdes and "scaffold_<N>" in case of a5
                    return '_'.join( (assmblr_name + "assembly", node_or_scaff, node_scaff_num ))
                # end if
            # end if
        # end if
    # end for

    # If structure of hit name is strange
    if re_search(hit_name_patt, modif_hit_name) is None:
        return modif_hit_name.strip().replace(' ', '_')   # return full name
    # end if

    taxa_name = modif_hit_name.partition(',')[0]
    taxa_splitnames = taxa_name.strip().split('_')

    # If hit is a phage sequence
    if taxa_splitnames[1] == "phage":
        # Assumming that the man who sortes by genus or species isn't interested in phage strain name
        if sens == "genus" or sens == "species":
            return '_'.join( [taxa_splitnames[0], taxa_splitnames[1]] ) # return "<Host_name> phage"
        else:
            return taxa_name.replace(' ', '_')   # return full name if we sort by strain
        # end if
    # end if

    if sens == "genus":
        return taxa_splitnames[0] # return genus
    
    elif sens == "species":
        # if species is not specified
        if taxa_splitnames[1] == "sp.":
            return taxa_name.replace(' ', '_')   # return full name
        else:
            return '_'.join( [taxa_splitnames[0], taxa_splitnames[1]] ) # return genus and species
        # end if
    elif sens == "strain":
        return taxa_name.replace(' ', '_')   # return full name
    # end if

    # Execution should not reach here
    raise Exception("Taxonomy name formatting error!")
# end def format_taxonomy_name


def read_fastq_record(read_file, fmt_func):
    """
    :param read_file: file instance of FASTQ file to retrieve sequences from;
    :type fasta_file: _io.TextIOWrapper or gzip.GzipFile;
    :param fmt_func: function from 'FORMATTING_FUNCS' tuple;

    Returns dictionary of the following structure:
    {
        "seq_id": ID_of_sequence,
        "seq": sequence_itself,
        "opt_id": the_third_line,
        "qual_line": quality_line
    }
    """

    fastq_rec = dict()

    try:
        fastq_rec = {                    #read all 4 lines of fastq-record
            "seq_id": fmt_func(read_file.readline()),
            "seq": fmt_func(read_file.readline()),
            "opt_id": fmt_func(read_file.readline()),
            "qual_line": fmt_func(read_file.readline())
        }
    except Exception as err:
        printl("\nAn error occured while reading from infile")
        printl( str(err) )
        platf_depend_exit(1)
    # end try

    return fastq_rec
# end def read_fastq_record

def read_fasta_record(fasta_file, fmt_func):
    """
    :param fasta_file: file instance of FASTA file to retrieve sequences from;
    :type fasta_file: _io.TextIOWrapper or gzip.GzipFile;
    :param fmt_func: function from 'FORMATTING_FUNCS' tuple;

    Returns dictionary of the following structure:
    {
        "seq_id": ID_of_sequence,
        "seq": sequence_itself
    }
    """

    fasta_rec = dict()

    try:
        global next_id_line
        line = fmt_func(fasta_file.readline())
        packet = ""

        stop = False
        if not next_id_line is None:
            packet += next_id_line
        # end if
        packet += line

        while not stop:
            line = fmt_func(fasta_file.readline())
            if line.startswith('>'):
                stop = True
            # end if
            if line == "":
                break
            # end if
            packet += line
        # end while

        if line != "":
            next_id_line = packet.splitlines()[-1]+'\n'
            packet = '\n'.join(packet.splitlines()[:-1])
        else:
            next_id_line = None
            packet = packet.strip()
        # end if

        fasta_rec = {                    #read all 2 lines of FASTA-record
            "seq_id": packet.splitlines()[0],
            "seq": '\n'.join( packet.splitlines()[1:] )+'\n'
        }
    except Exception as err:
        printl("\nAn error occured while reading from infile")
        printl( str(err) )
        platf_depend_exit(1)
    # end try

    return fasta_rec
# end def read_fasta_record


def write_fastq_record(outfile_path, fastq_record):
    """
    :param outfile_path: file, which data from fastq_record is written in
    :type outfile_path: _io.TextIOWrapper
    :param fastq_record: dict of 4 elements. Elements are four corresponding lines of FASTQ
    :type fastq_record: dict<str: str>

    Returns None
    """
    try:
        with open_as_gzip(outfile_path, 'ab') as sorted_file:
            sorted_file.write(bytes(fastq_record["seq_id"], "utf-8"))
            sorted_file.write(bytes(fastq_record["seq"], "utf-8"))
            sorted_file.write(bytes(fastq_record["opt_id"], "utf-8"))
            sorted_file.write(bytes(fastq_record["qual_line"], "utf-8"))
        # end with
    
    except Exception as exc:
        printl("\nAn error occured while writing to outfile")
        printl( str(exc) )
        platf_depend_exit(1)
    # end try
# end def write_fastq_record


def write_fasta_record(outfile_path, fasta_record):
    """
    :param outfile_path: file, which data from fasta_record is written in
    :type outfile_path: _io.TextIOWrapper
    :param fasta_record: dict of 2 elements. Elements are four corresponding lines of FASTA
    :type fasta_record: dict<str: str>
    """
    try:
        with open_as_gzip(outfile_path, 'ab') as sorted_file:
            sorted_file.write(bytes(fasta_record["seq_id"]+'\n', "utf-8"))
            sorted_file.write(bytes(fasta_record["seq"], "utf-8"))
        # end with
    
    except Exception as exc:
        printl("\nAn error occured while writing to outfile")
        printl( str(exc) )
        platf_depend_exit(1)
    # end try
# end def write_fasta_record


is_gzipped = lambda f: True if f.endswith(".gz") else False
OPEN_FUNCS = (open, open_as_gzip)

# Data from plain text and gzipped should be parsed in different way,
#   because data from .gz is read as 'bytes', not 'str'.
FORMATTING_FUNCS = (
    lambda line: line,   # format text line
    lambda line: line.decode("utf-8")  # format gzipped line
)


# |===== Create output directory =====|
if not os.path.exists(outdir_path):
    try:
        os.makedirs(outdir_path)
    except Exception as err:
        printl(err_fmt("unable to create output directory!"))
        printl( str(err) )
        platf_depend_exit(1)
    # end try
# end if


def get_curr_res_dir(fq_fa_path, prober_res_dir):
    """
    Function returns path to current result directory. This current result directory corresponds to
        the file that is sorted now.

    :param fq_fa_path: path to FASTA or FASTQ file that is sorted now;
    :type fq_fa_path: str;
    :param prober_res_dir: path to "prober result" directory.
        Current result directory is it's subdirectory;
    :type prober_res_dir: str;
    """

    # dpath means "directory path"
    new_dpath = os.path.join(prober_res_dir, os.path.basename(fq_fa_path)) # get rid of absolute path
    new_dpath = re_search(r"(.*)\.(m)?f(ast)?(a|q)", new_dpath).group(1) # get rid of extention

    return new_dpath
# end def get_curr_res_dir


# |=== Function for configuring dictionary containing information generated by barapost-v3-5b.py ===|

def get_res_tsv_fpath(new_dpath):
    """
    Function returns current TSV file. Sorting will be performad according to this file.

    :param new_dpath: current result directory;
    :type new_dpath: str;
    """

    brpst_resfile_patt = r".+_result\.tsv$"

    is_similar_to_tsv_res = lambda f: True if not re_search(brpst_resfile_patt, f) is None else False

    if not os.path.exists(new_dpath):
        printl(err_fmt("directory '{}' does not exist!".format(new_dpath)))
        printl(""" Please make sure you have 'prober_result' directory and
    file '{}...' have been processed by 'barapost-v3-5b.py'""".format(os.path.basename(new_dpath)))
        printl("""Also this error might occur if you forget to specify result directory
    generated by 'prober.py' with '-r' option.""")
        platf_depend_exit(0)
    # end if

    # Recent file will be the first in sorted list
    tsv_res_fpath = list( filter(is_similar_to_tsv_res, sorted(os.listdir(new_dpath))) )[0]

    return os.path.join(new_dpath, tsv_res_fpath)
# end def get_res_tsv_fpath


def sort_fastqa_file(fq_fa_path):
    """
    Function for sorting FASTQ and FASTA files.
    It stays separately from analoguous code from the kernel loop because
        interaction with HDF5 files and platin text ones have rather different interfases.
    It would be an ad hoc trick to implement a context manager wrapping for HDF5 files
        in order only to create an interface that would look like plain text files' one.

    :param fq_fa_path: path to FASTA (of FASTA) file meant to be processed;
    :type fq_fa_path: str;
    """

    global seqs_pass
    global seqs_qual_fail

    new_dpath = get_curr_res_dir(fq_fa_path, prober_res_dir)
    tsv_res_fpath = get_res_tsv_fpath(new_dpath)
    resfile_lines = configure_resfile_lines(tsv_res_fpath)

    how_to_open = OPEN_FUNCS[ is_gzipped(fq_fa_path) ] # get ready to open gzipped files
    if is_fastq(fq_fa_path):
        num_reads = int (sum(1 for line in how_to_open(fq_fa_path)) / LINES_PER_READ_FASTQ) # count number of reads in file
    else:
        num_reads = sum(1 if line[0] == '>' else 0 for line in how_to_open(fq_fa_path))
    # end if

    # Get function that will read one record -- FASTQ or FASTA, in dependence of your file
    read_fun = read_fastq_record if is_fastq(fq_fa_path) else read_fasta_record
    # Get function that will write one record -- FASTQ or FASTA, in dependence of your file
    write_fun = write_fastq_record if is_fastq(fq_fa_path) else write_fasta_record
    
    with how_to_open(fq_fa_path) as source_fastq_file:

        fmt_func = FORMATTING_FUNCS[ is_gzipped(fq_fa_path) ]

        for i in range(num_reads):

            fastq_rec = read_fun(source_fastq_file, fmt_func) # get FASTQ or FASTA record
            read_name = intern(fastq_rec["seq_id"].partition(' ')[0][1:]) # get ID of the sequence

            try:
                hit_name, ph33_qual = resfile_lines[read_name] # find hit corresponding to this sequence
            except KeyError:
                printl("\n\t\a !! - Warning: read '{}' not found in '{}' result file".format(read_name, prober_res_dir))
                printl("Make sure that this read has been already processed by 'prober-v1-12c.py' and 'barapost-v3-5b.py'.")
                continue
            # If read is found in TSV file:
            else:

                if ph33_qual != '-':
                    try:
                        ph33_qual = float(ph33_qual)
                    except ValueError as verr:
                        printl(err_rmt("Phred33 quality of a read is not a float number!"))
                        printl(" Please, contact the developer.")
                        platf_depend_exit(1)
                    else:
                        if ph33_qual < min_ph33_qual:
                            # Get name of resilt FASTQ file to write this read in
                            sorted_file_path = os.path.join(outdir_path, "qual_less_than_Q{}.fastq.gz".format(int(min_ph33_qual)))
                            printn("\r{} - {}/{} reads are sorted  ".format(get_work_time(), i+1, num_reads))
                            write_fun(sorted_file_path, fastq_rec) # write current read to sorted file
                            seqs_qual_fail += 1
                            continue
                        # end if
                    # end try
                # end if

                # Get name of resilt FASTQ file to write this read in
                sorted_file_path = os.path.join(outdir_path, "{}.fast{}.gz".format(hit_name,
                    'q' if is_fastq(fq_fa_path) else 'a'))
                write_fun(sorted_file_path, fastq_rec) # write current read to sorted file
                seqs_pass += 1
            # end try

            printn("\r{} - {}/{} reads are sorted  ".format(get_work_time(), i+1, num_reads))
        # end for
        print() # print space to console but not to log file
        logfile.write("\r{} - {}/{} reads are sorted\n".format(get_work_time(), i+1, num_reads))
        printl('-'*20)
    # end with

# end def sort_fastqa_file


def sort_fast5_file(f5_path):
    """
    Function for sorting FAST5 files.
    It stays separately from analoguous code from the kernel loop because
        interaction with HDF5 files and platin text ones have rather different interfases.
    It would be an ad hoc trick to implement a context manager wrapping for HDF5 files
        in order only to create an interface that would look like plain text files' one.

    :param f5_path: path to FAST5 file meant to be processed;
    :type f5_path: str;
    """

    global seqs_pass
    global seqs_qual_fail

    new_dpath = glob("{}{}*{}*".format(prober_res_dir, os.sep, get_checkstr(f5_path)))[0]
    tsv_res_fpath = get_res_tsv_fpath(new_dpath)
    resfile_lines = configure_resfile_lines(tsv_res_fpath)

    from_f5 = h5py.File(f5_path, 'r')
    num_reads = len(from_f5)

    for i, read_name in enumerate(from_f5):

        if not read_name.startswith("read_"):
            printl("Name of read '{}' from FAST5 file has format that is unforseen by the developer.".format(read_name))
            printl("Please, contact the developer.")
            platf_depend_exit(1)
        # end if

        try:
            hit_name, ph33_qual = resfile_lines[read_name[5:]] # omit 'read_' in the beginning of FAST5 group's name
        except KeyError:
            printl(err_fmt("read '{}' not found in '{}' result file".format(read_name, prober_res_dir)))
            printl("Make sure that this read has been already processed by 'prober-v1-12c.py' and 'barapost-v3-5b.py'.")
            platf_depend_exit(1)
        else:
            if ph33_qual != '-':
                try:
                    ph33_qual = float(ph33_qual)
                except ValueError as verr:
                    printl(err_rmt("Phred33 quality of a read is not a float number!"))
                    printl(" Please, contact the developer.")
                    platf_depend_exit(1)
                else:
                    if ph33_qual < min_ph33_qual:
                        # Get name of resilt FASTQ file to write this read in
                        sorted_file_path = os.path.join(outdir_path, "qual_less_than_Q{}.fast5".format(int(min_ph33_qual)))
                        printn("\r{} - {}/{} reads are sorted  ".format(get_work_time(), i+1, num_reads))
                        to_f5 = h5py.File(sorted_file_path, 'a')
                        from_f5.copy(read_name, to_f5)
                        seqs_qual_fail += 1
                        continue
                    # end if
                # end try
            # end if

            # Get name of resilt FASTQ file to write this read in
            sorted_file_path = os.path.join(outdir_path, "{}.fast5".format(hit_name))
            to_f5 = h5py.File(sorted_file_path, 'a')
            from_f5.copy(read_name, to_f5)
            seqs_pass += 1
        # end try
        printn("\r{} - {}/{} reads are sorted  ".format(get_work_time(), i+1, num_reads))
    # end for

    print() # print blank line to console but not to log file
    logfile.write("\r{} - {}/{} reads are sorted\n".format(get_work_time(), i+1, num_reads))
    printl('-'*20)
# end def sort_fast5_file


def configure_resfile_lines(tsv_res_fpath):
    """
    Function returns dictionary, where keys are sequence (i.e. sequences meant to be sorted) IDs,
        and values are corresponding hit names.

    :param tsv_res_fpath: path to current TSV file. Sorting will be performed accorfing to this TSV file;
    :type tsv_res_fpath: str;
    """

    resfile_lines = dict()

    with open(tsv_res_fpath, 'r') as brpst_resfile:

        brpst_resfile.readline() # pass the head of the table
        line = brpst_resfile.readline().strip() # get the first informative line

        while line != "":
            splt = line.split('\t')
            read_name = intern(splt[0])
            hit_name = splt[1]
            phred33 = splt[8]
            resfile_lines[read_name] = [hit_name, phred33]
            line = brpst_resfile.readline().strip() # get next line
        # end while
    # end with

    # |===== Format taxonomy names =====|
    for read_name in resfile_lines.keys():
        resfile_lines[read_name][0] = format_taxonomy_name(resfile_lines[read_name][0], sens)
    # end for

    return resfile_lines
# end def configure_resfile_lines


# |===== Proceed =====|

printl( get_work_time() + " ({}) ".format(strftime("%d.%m.%Y %H:%M:%S", localtime(start_time))) + "- Start working\n")

printl(" - Sorting sensitivity: '{}';".format(sens))
printl(" - Minimum mean Phred33 quality of a read to keep: {};\n".format(min_ph33_qual))

printl("\nFollowing files will be processed:")
for i, path in enumerate(fq_fa_list):
    printl("  {}. {}".format(i+1, path))
# end for
printl('-'*20 + '\n')


LINES_PER_READ_FASTQ = 4
is_fastq = lambda f: True if not re_search(r".*\.fastq(\.gz)?$", f) is None else False
num_files = len(fq_fa_list)
next_id_line = None

seqs_pass, seqs_qual_fail = 0, 0

for j, fq_fa_path in enumerate(fq_fa_list):

    printl("{} - '{}': start sorting".format(get_work_time(), os.path.basename(fq_fa_path)))

    # Interface of interactiong with HDF5 files are quite different from platin text ones.
    # So it is beter to write a separate function for them.
    if not fq_fa_path.endswith(".fast5"):
        sort_fastqa_file(fq_fa_path)
    else:
        sort_fast5_file(fq_fa_path)
    # end if
# end for

printl("\n{} sequences have been processed.".format(seqs_pass + seqs_qual_fail))
if seqs_qual_fail:
    printl("{} of them have passed quality controle (Q{}).".format(seqs_pass, int(min_ph33_qual)))
# end if

end_time = time()
printl( '\n'+get_work_time() + " ({}) ".format(strftime("%d.%m.%Y %H:%M:%S", localtime(end_time))) + "- Sorting is completed!\n")
platf_depend_exit(0)